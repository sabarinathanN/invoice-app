"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@headlessui-float";
exports.ids = ["vendor-chunks/@headlessui-float"];
exports.modules = {

/***/ "(ssr)/./node_modules/@headlessui-float/react/dist/headlessui-float.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@headlessui-float/react/dist/headlessui-float.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Float: () => (/* binding */ xr),\n/* harmony export */   renderFloatingElement: () => (/* binding */ $e),\n/* harmony export */   renderReferenceElement: () => (/* binding */ lt),\n/* harmony export */   tailwindcssOriginClassResolver: () => (/* binding */ ir),\n/* harmony export */   tailwindcssOriginSafelist: () => (/* binding */ Er),\n/* harmony export */   tailwindcssRtlOriginClassResolver: () => (/* binding */ Rr),\n/* harmony export */   tailwindcssRtlOriginSafelist: () => (/* binding */ wr),\n/* harmony export */   useOutsideClick: () => (/* binding */ cr)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _headlessui_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @headlessui/react */ \"(ssr)/./node_modules/@headlessui/react/dist/components/portal/portal.js\");\n/* harmony import */ var _headlessui_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @headlessui/react */ \"(ssr)/./node_modules/@headlessui/react/dist/components/transitions/transition.js\");\n/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/react */ \"(ssr)/./node_modules/@floating-ui/react/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs\");\n/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @floating-ui/react */ \"(ssr)/./node_modules/@floating-ui/react/dist/floating-ui.react.mjs\");\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/dom */ \"(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\");\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @floating-ui/dom */ \"(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\nvar Yt = Object.defineProperty;\nvar Lt = (t, i, o) => i in t ? Yt(t, i, { enumerable: !0, configurable: !0, writable: !0, value: o }) : t[i] = o;\nvar je = (t, i, o) => (Lt(t, typeof i != \"symbol\" ? i + \"\" : i, o), o);\n\n\n\n\nvar Se = { exports: {} }, Z = {};\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Qe;\nfunction Zt() {\n  if (Qe)\n    return Z;\n  Qe = 1;\n  var t = react__WEBPACK_IMPORTED_MODULE_0__, i = Symbol.for(\"react.element\"), o = Symbol.for(\"react.fragment\"), r = Object.prototype.hasOwnProperty, u = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, h = { key: !0, ref: !0, __self: !0, __source: !0 };\n  function f(m, d, b) {\n    var l, s = {}, C = null, y = null;\n    b !== void 0 && (C = \"\" + b), d.key !== void 0 && (C = \"\" + d.key), d.ref !== void 0 && (y = d.ref);\n    for (l in d)\n      r.call(d, l) && !h.hasOwnProperty(l) && (s[l] = d[l]);\n    if (m && m.defaultProps)\n      for (l in d = m.defaultProps, d)\n        s[l] === void 0 && (s[l] = d[l]);\n    return { $$typeof: i, type: m, key: C, ref: y, props: s, _owner: u.current };\n  }\n  return Z.Fragment = o, Z.jsx = f, Z.jsxs = f, Z;\n}\nvar Q = {};\n/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar et;\nfunction Qt() {\n  return et || (et = 1,  true && function() {\n    var t = react__WEBPACK_IMPORTED_MODULE_0__, i = Symbol.for(\"react.element\"), o = Symbol.for(\"react.portal\"), r = Symbol.for(\"react.fragment\"), u = Symbol.for(\"react.strict_mode\"), h = Symbol.for(\"react.profiler\"), f = Symbol.for(\"react.provider\"), m = Symbol.for(\"react.context\"), d = Symbol.for(\"react.forward_ref\"), b = Symbol.for(\"react.suspense\"), l = Symbol.for(\"react.suspense_list\"), s = Symbol.for(\"react.memo\"), C = Symbol.for(\"react.lazy\"), y = Symbol.for(\"react.offscreen\"), R = Symbol.iterator, O = \"@@iterator\";\n    function W(e) {\n      if (e === null || typeof e != \"object\")\n        return null;\n      var n = R && e[R] || e[O];\n      return typeof n == \"function\" ? n : null;\n    }\n    var A = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    function x(e) {\n      {\n        for (var n = arguments.length, a = new Array(n > 1 ? n - 1 : 0), c = 1; c < n; c++)\n          a[c - 1] = arguments[c];\n        Y(\"error\", e, a);\n      }\n    }\n    function Y(e, n, a) {\n      {\n        var c = A.ReactDebugCurrentFrame, p = c.getStackAddendum();\n        p !== \"\" && (n += \"%s\", a = a.concat([p]));\n        var w = a.map(function(g) {\n          return String(g);\n        });\n        w.unshift(\"Warning: \" + n), Function.prototype.apply.call(console[e], console, w);\n      }\n    }\n    var F = !1, N = !1, M = !1, J = !1, G = !1, le;\n    le = Symbol.for(\"react.module.reference\");\n    function De(e) {\n      return !!(typeof e == \"string\" || typeof e == \"function\" || e === r || e === h || G || e === u || e === b || e === l || J || e === y || F || N || M || typeof e == \"object\" && e !== null && (e.$$typeof === C || e.$$typeof === s || e.$$typeof === f || e.$$typeof === m || e.$$typeof === d || // This needs to include all possible module reference object\n      // types supported by any Flight configuration anywhere since\n      // we don't know which Flight build this will end up being used\n      // with.\n      e.$$typeof === le || e.getModuleId !== void 0));\n    }\n    function We(e, n, a) {\n      var c = e.displayName;\n      if (c)\n        return c;\n      var p = n.displayName || n.name || \"\";\n      return p !== \"\" ? a + \"(\" + p + \")\" : a;\n    }\n    function fe(e) {\n      return e.displayName || \"Context\";\n    }\n    function $(e) {\n      if (e == null)\n        return null;\n      if (typeof e.tag == \"number\" && x(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), typeof e == \"function\")\n        return e.displayName || e.name || null;\n      if (typeof e == \"string\")\n        return e;\n      switch (e) {\n        case r:\n          return \"Fragment\";\n        case o:\n          return \"Portal\";\n        case h:\n          return \"Profiler\";\n        case u:\n          return \"StrictMode\";\n        case b:\n          return \"Suspense\";\n        case l:\n          return \"SuspenseList\";\n      }\n      if (typeof e == \"object\")\n        switch (e.$$typeof) {\n          case m:\n            var n = e;\n            return fe(n) + \".Consumer\";\n          case f:\n            var a = e;\n            return fe(a._context) + \".Provider\";\n          case d:\n            return We(e, e.render, \"ForwardRef\");\n          case s:\n            var c = e.displayName || null;\n            return c !== null ? c : $(e.type) || \"Memo\";\n          case C: {\n            var p = e, w = p._payload, g = p._init;\n            try {\n              return $(g(w));\n            } catch {\n              return null;\n            }\n          }\n        }\n      return null;\n    }\n    var L = Object.assign, U = 0, de, ve, he, ge, me, ye, be;\n    function re() {\n    }\n    re.__reactDisabledLog = !0;\n    function vt() {\n      {\n        if (U === 0) {\n          de = console.log, ve = console.info, he = console.warn, ge = console.error, me = console.group, ye = console.groupCollapsed, be = console.groupEnd;\n          var e = {\n            configurable: !0,\n            enumerable: !0,\n            value: re,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            info: e,\n            log: e,\n            warn: e,\n            error: e,\n            group: e,\n            groupCollapsed: e,\n            groupEnd: e\n          });\n        }\n        U++;\n      }\n    }\n    function ht() {\n      {\n        if (U--, U === 0) {\n          var e = {\n            configurable: !0,\n            enumerable: !0,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            log: L({}, e, {\n              value: de\n            }),\n            info: L({}, e, {\n              value: ve\n            }),\n            warn: L({}, e, {\n              value: he\n            }),\n            error: L({}, e, {\n              value: ge\n            }),\n            group: L({}, e, {\n              value: me\n            }),\n            groupCollapsed: L({}, e, {\n              value: ye\n            }),\n            groupEnd: L({}, e, {\n              value: be\n            })\n          });\n        }\n        U < 0 && x(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n      }\n    }\n    var pe = A.ReactCurrentDispatcher, Ee;\n    function ne(e, n, a) {\n      {\n        if (Ee === void 0)\n          try {\n            throw Error();\n          } catch (p) {\n            var c = p.stack.trim().match(/\\n( *(at )?)/);\n            Ee = c && c[1] || \"\";\n          }\n        return `\n` + Ee + e;\n      }\n    }\n    var we = !1, oe;\n    {\n      var gt = typeof WeakMap == \"function\" ? WeakMap : Map;\n      oe = new gt();\n    }\n    function Ye(e, n) {\n      if (!e || we)\n        return \"\";\n      {\n        var a = oe.get(e);\n        if (a !== void 0)\n          return a;\n      }\n      var c;\n      we = !0;\n      var p = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var w;\n      w = pe.current, pe.current = null, vt();\n      try {\n        if (n) {\n          var g = function() {\n            throw Error();\n          };\n          if (Object.defineProperty(g.prototype, \"props\", {\n            set: function() {\n              throw Error();\n            }\n          }), typeof Reflect == \"object\" && Reflect.construct) {\n            try {\n              Reflect.construct(g, []);\n            } catch (D) {\n              c = D;\n            }\n            Reflect.construct(e, [], g);\n          } else {\n            try {\n              g.call();\n            } catch (D) {\n              c = D;\n            }\n            e.call(g.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (D) {\n            c = D;\n          }\n          e();\n        }\n      } catch (D) {\n        if (D && c && typeof D.stack == \"string\") {\n          for (var v = D.stack.split(`\n`), P = c.stack.split(`\n`), _ = v.length - 1, T = P.length - 1; _ >= 1 && T >= 0 && v[_] !== P[T]; )\n            T--;\n          for (; _ >= 1 && T >= 0; _--, T--)\n            if (v[_] !== P[T]) {\n              if (_ !== 1 || T !== 1)\n                do\n                  if (_--, T--, T < 0 || v[_] !== P[T]) {\n                    var k = `\n` + v[_].replace(\" at new \", \" at \");\n                    return e.displayName && k.includes(\"<anonymous>\") && (k = k.replace(\"<anonymous>\", e.displayName)), typeof e == \"function\" && oe.set(e, k), k;\n                  }\n                while (_ >= 1 && T >= 0);\n              break;\n            }\n        }\n      } finally {\n        we = !1, pe.current = w, ht(), Error.prepareStackTrace = p;\n      }\n      var B = e ? e.displayName || e.name : \"\", Ke = B ? ne(B) : \"\";\n      return typeof e == \"function\" && oe.set(e, Ke), Ke;\n    }\n    function mt(e, n, a) {\n      return Ye(e, !1);\n    }\n    function yt(e) {\n      var n = e.prototype;\n      return !!(n && n.isReactComponent);\n    }\n    function ie(e, n, a) {\n      if (e == null)\n        return \"\";\n      if (typeof e == \"function\")\n        return Ye(e, yt(e));\n      if (typeof e == \"string\")\n        return ne(e);\n      switch (e) {\n        case b:\n          return ne(\"Suspense\");\n        case l:\n          return ne(\"SuspenseList\");\n      }\n      if (typeof e == \"object\")\n        switch (e.$$typeof) {\n          case d:\n            return mt(e.render);\n          case s:\n            return ie(e.type, n, a);\n          case C: {\n            var c = e, p = c._payload, w = c._init;\n            try {\n              return ie(w(p), n, a);\n            } catch {\n            }\n          }\n        }\n      return \"\";\n    }\n    var ae = Object.prototype.hasOwnProperty, Le = {}, Ne = A.ReactDebugCurrentFrame;\n    function ue(e) {\n      if (e) {\n        var n = e._owner, a = ie(e.type, e._source, n ? n.type : null);\n        Ne.setExtraStackFrame(a);\n      } else\n        Ne.setExtraStackFrame(null);\n    }\n    function bt(e, n, a, c, p) {\n      {\n        var w = Function.call.bind(ae);\n        for (var g in e)\n          if (w(e, g)) {\n            var v = void 0;\n            try {\n              if (typeof e[g] != \"function\") {\n                var P = Error((c || \"React class\") + \": \" + a + \" type `\" + g + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof e[g] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                throw P.name = \"Invariant Violation\", P;\n              }\n              v = e[g](n, g, c, a, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n            } catch (_) {\n              v = _;\n            }\n            v && !(v instanceof Error) && (ue(p), x(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", c || \"React class\", a, g, typeof v), ue(null)), v instanceof Error && !(v.message in Le) && (Le[v.message] = !0, ue(p), x(\"Failed %s type: %s\", a, v.message), ue(null));\n          }\n      }\n    }\n    var pt = Array.isArray;\n    function Re(e) {\n      return pt(e);\n    }\n    function Et(e) {\n      {\n        var n = typeof Symbol == \"function\" && Symbol.toStringTag, a = n && e[Symbol.toStringTag] || e.constructor.name || \"Object\";\n        return a;\n      }\n    }\n    function wt(e) {\n      try {\n        return Me(e), !1;\n      } catch {\n        return !0;\n      }\n    }\n    function Me(e) {\n      return \"\" + e;\n    }\n    function Ue(e) {\n      if (wt(e))\n        return x(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", Et(e)), Me(e);\n    }\n    var K = A.ReactCurrentOwner, Rt = {\n      key: !0,\n      ref: !0,\n      __self: !0,\n      __source: !0\n    }, Ve, Be, xe;\n    xe = {};\n    function xt(e) {\n      if (ae.call(e, \"ref\")) {\n        var n = Object.getOwnPropertyDescriptor(e, \"ref\").get;\n        if (n && n.isReactWarning)\n          return !1;\n      }\n      return e.ref !== void 0;\n    }\n    function Ct(e) {\n      if (ae.call(e, \"key\")) {\n        var n = Object.getOwnPropertyDescriptor(e, \"key\").get;\n        if (n && n.isReactWarning)\n          return !1;\n      }\n      return e.key !== void 0;\n    }\n    function _t(e, n) {\n      if (typeof e.ref == \"string\" && K.current && n && K.current.stateNode !== n) {\n        var a = $(K.current.type);\n        xe[a] || (x('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', $(K.current.type), e.ref), xe[a] = !0);\n      }\n    }\n    function Tt(e, n) {\n      {\n        var a = function() {\n          Ve || (Ve = !0, x(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", n));\n        };\n        a.isReactWarning = !0, Object.defineProperty(e, \"key\", {\n          get: a,\n          configurable: !0\n        });\n      }\n    }\n    function jt(e, n) {\n      {\n        var a = function() {\n          Be || (Be = !0, x(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", n));\n        };\n        a.isReactWarning = !0, Object.defineProperty(e, \"ref\", {\n          get: a,\n          configurable: !0\n        });\n      }\n    }\n    var Pt = function(e, n, a, c, p, w, g) {\n      var v = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: i,\n        // Built-in properties that belong on the element\n        type: e,\n        key: n,\n        ref: a,\n        props: g,\n        // Record the component responsible for creating this element.\n        _owner: w\n      };\n      return v._store = {}, Object.defineProperty(v._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: !1\n      }), Object.defineProperty(v, \"_self\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: c\n      }), Object.defineProperty(v, \"_source\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: p\n      }), Object.freeze && (Object.freeze(v.props), Object.freeze(v)), v;\n    };\n    function St(e, n, a, c, p) {\n      {\n        var w, g = {}, v = null, P = null;\n        a !== void 0 && (Ue(a), v = \"\" + a), Ct(n) && (Ue(n.key), v = \"\" + n.key), xt(n) && (P = n.ref, _t(n, p));\n        for (w in n)\n          ae.call(n, w) && !Rt.hasOwnProperty(w) && (g[w] = n[w]);\n        if (e && e.defaultProps) {\n          var _ = e.defaultProps;\n          for (w in _)\n            g[w] === void 0 && (g[w] = _[w]);\n        }\n        if (v || P) {\n          var T = typeof e == \"function\" ? e.displayName || e.name || \"Unknown\" : e;\n          v && Tt(g, T), P && jt(g, T);\n        }\n        return Pt(e, v, P, p, c, K.current, g);\n      }\n    }\n    var Ce = A.ReactCurrentOwner, ze = A.ReactDebugCurrentFrame;\n    function V(e) {\n      if (e) {\n        var n = e._owner, a = ie(e.type, e._source, n ? n.type : null);\n        ze.setExtraStackFrame(a);\n      } else\n        ze.setExtraStackFrame(null);\n    }\n    var _e;\n    _e = !1;\n    function Te(e) {\n      return typeof e == \"object\" && e !== null && e.$$typeof === i;\n    }\n    function He() {\n      {\n        if (Ce.current) {\n          var e = $(Ce.current.type);\n          if (e)\n            return `\n\nCheck the render method of \\`` + e + \"`.\";\n        }\n        return \"\";\n      }\n    }\n    function Ot(e) {\n      {\n        if (e !== void 0) {\n          var n = e.fileName.replace(/^.*[\\\\\\/]/, \"\"), a = e.lineNumber;\n          return `\n\nCheck your code at ` + n + \":\" + a + \".\";\n        }\n        return \"\";\n      }\n    }\n    var qe = {};\n    function Ft(e) {\n      {\n        var n = He();\n        if (!n) {\n          var a = typeof e == \"string\" ? e : e.displayName || e.name;\n          a && (n = `\n\nCheck the top-level render call using <` + a + \">.\");\n        }\n        return n;\n      }\n    }\n    function Xe(e, n) {\n      {\n        if (!e._store || e._store.validated || e.key != null)\n          return;\n        e._store.validated = !0;\n        var a = Ft(n);\n        if (qe[a])\n          return;\n        qe[a] = !0;\n        var c = \"\";\n        e && e._owner && e._owner !== Ce.current && (c = \" It was passed a child from \" + $(e._owner.type) + \".\"), V(e), x('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', a, c), V(null);\n      }\n    }\n    function Je(e, n) {\n      {\n        if (typeof e != \"object\")\n          return;\n        if (Re(e))\n          for (var a = 0; a < e.length; a++) {\n            var c = e[a];\n            Te(c) && Xe(c, n);\n          }\n        else if (Te(e))\n          e._store && (e._store.validated = !0);\n        else if (e) {\n          var p = W(e);\n          if (typeof p == \"function\" && p !== e.entries)\n            for (var w = p.call(e), g; !(g = w.next()).done; )\n              Te(g.value) && Xe(g.value, n);\n        }\n      }\n    }\n    function kt(e) {\n      {\n        var n = e.type;\n        if (n == null || typeof n == \"string\")\n          return;\n        var a;\n        if (typeof n == \"function\")\n          a = n.propTypes;\n        else if (typeof n == \"object\" && (n.$$typeof === d || // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        n.$$typeof === s))\n          a = n.propTypes;\n        else\n          return;\n        if (a) {\n          var c = $(n);\n          bt(a, e.props, \"prop\", c, e);\n        } else if (n.PropTypes !== void 0 && !_e) {\n          _e = !0;\n          var p = $(n);\n          x(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", p || \"Unknown\");\n        }\n        typeof n.getDefaultProps == \"function\" && !n.getDefaultProps.isReactClassApproved && x(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n      }\n    }\n    function At(e) {\n      {\n        for (var n = Object.keys(e.props), a = 0; a < n.length; a++) {\n          var c = n[a];\n          if (c !== \"children\" && c !== \"key\") {\n            V(e), x(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", c), V(null);\n            break;\n          }\n        }\n        e.ref !== null && (V(e), x(\"Invalid attribute `ref` supplied to `React.Fragment`.\"), V(null));\n      }\n    }\n    function Ge(e, n, a, c, p, w) {\n      {\n        var g = De(e);\n        if (!g) {\n          var v = \"\";\n          (e === void 0 || typeof e == \"object\" && e !== null && Object.keys(e).length === 0) && (v += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\");\n          var P = Ot(p);\n          P ? v += P : v += He();\n          var _;\n          e === null ? _ = \"null\" : Re(e) ? _ = \"array\" : e !== void 0 && e.$$typeof === i ? (_ = \"<\" + ($(e.type) || \"Unknown\") + \" />\", v = \" Did you accidentally export a JSX literal instead of a component?\") : _ = typeof e, x(\"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", _, v);\n        }\n        var T = St(e, n, a, p, w);\n        if (T == null)\n          return T;\n        if (g) {\n          var k = n.children;\n          if (k !== void 0)\n            if (c)\n              if (Re(k)) {\n                for (var B = 0; B < k.length; B++)\n                  Je(k[B], e);\n                Object.freeze && Object.freeze(k);\n              } else\n                x(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");\n            else\n              Je(k, e);\n        }\n        return e === r ? At(T) : kt(T), T;\n      }\n    }\n    function $t(e, n, a) {\n      return Ge(e, n, a, !0);\n    }\n    function It(e, n, a) {\n      return Ge(e, n, a, !1);\n    }\n    var Dt = It, Wt = $t;\n    Q.Fragment = r, Q.jsx = Dt, Q.jsxs = Wt;\n  }()), Q;\n}\n false ? 0 : Se.exports = Qt();\nvar E = Se.exports;\nfunction z(t) {\n  const i = typeof window < \"u\" ? window.devicePixelRatio : 1;\n  return Math.round(t * i) / i;\n}\nclass er {\n  constructor() {\n    je(this, \"current\", this.detect());\n    je(this, \"currentId\", 0);\n  }\n  set(i) {\n    this.current !== i && (this.currentId = 0, this.current = i);\n  }\n  reset() {\n    this.set(this.detect());\n  }\n  nextId() {\n    return ++this.currentId;\n  }\n  get isServer() {\n    return this.current === \"server\";\n  }\n  get isClient() {\n    return this.current === \"client\";\n  }\n  detect() {\n    return typeof window > \"u\" || typeof document > \"u\" ? \"server\" : \"client\";\n  }\n}\nconst q = new er(), nt = (t, i) => {\n  q.isServer ? (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(t, i) : (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(t, i);\n}, Pe = { serverHandoffComplete: !1 };\nfunction tr() {\n  const [t, i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(Pe.serverHandoffComplete);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    t !== !0 && i(!0);\n  }, [t]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    Pe.serverHandoffComplete === !1 && (Pe.serverHandoffComplete = !0);\n  }, []), t;\n}\nconst rr = (\n  // Prefer React's `useId` if it's available.\n  react__WEBPACK_IMPORTED_MODULE_0__.useId ?? function() {\n    const i = tr(), [o, r] = react__WEBPACK_IMPORTED_MODULE_0__.useState(i ? () => q.nextId() : null);\n    return nt(() => {\n      o === null && r(q.nextId());\n    }, [o]), o != null ? `${o}` : void 0;\n  }\n);\nfunction nr(t, i, o, r) {\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const u = [];\n    (typeof r.offset == \"number\" || typeof r.offset == \"object\" || typeof r.offset == \"function\") && u.push((0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.offset)(r.offset)), (r.flip === !0 || typeof r.flip == \"number\" || typeof r.flip == \"object\") && u.push((0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.flip)({\n      padding: typeof r.flip == \"number\" ? r.flip : void 0,\n      ...typeof r.flip == \"object\" ? r.flip : {}\n    })), (r.shift === !0 || typeof r.shift == \"number\" || typeof r.shift == \"object\") && u.push((0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.shift)({\n      padding: typeof r.shift == \"number\" ? r.shift : void 0,\n      ...typeof r.shift == \"object\" ? r.shift : {}\n    })), (r.autoPlacement === !0 || typeof r.autoPlacement == \"object\") && u.push((0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.autoPlacement)(\n      typeof r.autoPlacement == \"object\" ? r.autoPlacement : void 0\n    )), (r.arrow === !0 || typeof r.arrow == \"number\") && u.push((0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_2__.arrow)({\n      element: o,\n      padding: r.arrow === !0 ? 0 : r.arrow\n    })), u.push(...typeof r.middleware == \"function\" ? r.middleware({\n      referenceEl: i.reference,\n      floatingEl: i.floating\n    }) : r.middleware || []), (r.hide === !0 || typeof r.hide == \"object\") && u.push((0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.hide)(\n      typeof r.hide == \"object\" ? r.hide : void 0\n    )), t(u);\n  }, [\n    r.offset,\n    r.shift,\n    r.flip,\n    r.arrow,\n    r.autoPlacement,\n    r.hide,\n    r.middleware\n  ]);\n}\nfunction or(t, i, o) {\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (t && q.isClient && typeof ResizeObserver < \"u\" && i.current && i.current instanceof Element) {\n      const r = new ResizeObserver(([u]) => {\n        const h = u.borderBoxSize.reduce((f, { inlineSize: m }) => f + m, 0);\n        o(h);\n      });\n      return r.observe(i.current), () => {\n        r.disconnect(), o(null);\n      };\n    }\n  }, []);\n}\nconst Er = [\n  \"origin-bottom\",\n  \"origin-top\",\n  \"origin-right\",\n  \"origin-left\",\n  \"origin-bottom-left\",\n  \"origin-bottom-right\",\n  \"origin-top-left\",\n  \"origin-top-right\"\n], ir = (t) => {\n  switch (t) {\n    case \"top\":\n      return \"origin-bottom\";\n    case \"bottom\":\n      return \"origin-top\";\n    case \"left\":\n      return \"origin-right\";\n    case \"right\":\n      return \"origin-left\";\n    case \"top-start\":\n    case \"right-end\":\n      return \"origin-bottom-left\";\n    case \"top-end\":\n    case \"left-end\":\n      return \"origin-bottom-right\";\n    case \"right-start\":\n    case \"bottom-start\":\n      return \"origin-top-left\";\n    case \"left-start\":\n    case \"bottom-end\":\n      return \"origin-top-right\";\n    default:\n      return \"origin-center\";\n  }\n}, wr = [\n  \"origin-bottom\",\n  \"origin-top\",\n  \"ltr:origin-right rtl:origin-left\",\n  \"ltr:origin-left rtl:origin-right\",\n  \"ltr:origin-bottom-left rtl:origin-bottom-right\",\n  \"ltr:origin-bottom-right rtl:origin-bottom-left\",\n  \"ltr:origin-top-left rtl:origin-top-right\",\n  \"ltr:origin-top-right rtl:origin-top-left\"\n], Rr = (t) => {\n  switch (t) {\n    case \"top\":\n      return \"origin-bottom\";\n    case \"bottom\":\n      return \"origin-top\";\n    case \"left\":\n      return \"ltr:origin-right rtl:origin-left\";\n    case \"right\":\n      return \"ltr:origin-left rtl:origin-right\";\n    case \"top-start\":\n    case \"right-end\":\n      return \"ltr:origin-bottom-left rtl:origin-bottom-right\";\n    case \"top-end\":\n    case \"left-end\":\n      return \"ltr:origin-bottom-right rtl:origin-bottom-left\";\n    case \"right-start\":\n    case \"bottom-start\":\n      return \"ltr:origin-top-left rtl:origin-top-right\";\n    case \"left-start\":\n    case \"bottom-end\":\n      return \"ltr:origin-top-right rtl:origin-top-left\";\n    default:\n      return \"origin-center\";\n  }\n};\nfunction ar(t, i) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => typeof t.originClass == \"function\" ? t.originClass(i) : typeof t.originClass == \"string\" ? t.originClass : t.tailwindcssOriginClass ? ir(i) : \"\", [i, t.originClass, t.tailwindcssOriginClass]);\n}\nfunction ot(t, i, ...o) {\n  if (t in i) {\n    const u = i[t];\n    return typeof u == \"function\" ? u(...o) : u;\n  }\n  const r = new Error(\n    `Tried to handle \"${t}\" but there is no handler defined. Only defined handlers are: ${Object.keys(\n      i\n    ).map((u) => `\"${u}\"`).join(\", \")}.`\n  );\n  throw Error.captureStackTrace && Error.captureStackTrace(r, ot), r;\n}\nfunction it(t) {\n  return q.isServer ? null : t instanceof Node ? t.ownerDocument : t && Object.prototype.hasOwnProperty.call(t, \"current\") && t.current instanceof Node ? t.current.ownerDocument : document;\n}\nconst tt = [\n  \"[contentEditable=true]\",\n  \"[tabindex]\",\n  \"a[href]\",\n  \"area[href]\",\n  \"button:not([disabled])\",\n  \"iframe\",\n  \"input:not([disabled])\",\n  \"select:not([disabled])\",\n  \"textarea:not([disabled])\"\n].map(\n  // TODO: Remove this once JSDOM fixes the issue where an element that is\n  // \"hidden\" can be the document.activeElement, because this is not possible\n  // in real browsers.\n   false ? 0 : (t) => `${t}:not([tabindex='-1'])`\n).join(\",\");\nvar at = /* @__PURE__ */ ((t) => (t[t.Strict = 0] = \"Strict\", t[t.Loose = 1] = \"Loose\", t))(at || {});\nfunction ur(t, i = 0) {\n  var o;\n  return t === ((o = it(t)) == null ? void 0 : o.body) ? !1 : ot(i, {\n    0() {\n      return t.matches(tt);\n    },\n    1() {\n      let r = t;\n      for (; r !== null; ) {\n        if (r.matches(tt))\n          return !0;\n        r = r.parentElement;\n      }\n      return !1;\n    }\n  });\n}\nfunction sr(t) {\n  const i = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(t);\n  return nt(() => {\n    i.current = t;\n  }, [t]), i;\n}\nfunction I(t, i, o) {\n  const r = sr(i);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    function u(h) {\n      r.current(h);\n    }\n    return document.addEventListener(t, u, o), () => document.removeEventListener(t, u, o);\n  }, [t, o]);\n}\nfunction cr(t, i, o = !0) {\n  const r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n     false ? 0 : () => {\n      requestAnimationFrame(() => {\n        r.current = o;\n      });\n    },\n    [o]\n  );\n  function u(f, m) {\n    if (!r.current || f.defaultPrevented)\n      return;\n    const d = function l(s) {\n      return typeof s == \"function\" ? l(s()) : Array.isArray(s) || s instanceof Set ? s : [s];\n    }(t), b = m(f);\n    if (b !== null && b.getRootNode().contains(b)) {\n      for (const l of d) {\n        if (l === null)\n          continue;\n        const s = l instanceof HTMLElement ? l : l.current;\n        if (s != null && s.contains(b) || f.composed && f.composedPath().includes(s))\n          return;\n      }\n      return (\n        // This check alllows us to know whether or not we clicked on a \"focusable\" element like a\n        // button or an input. This is a backwards compatibility check so that you can open a <Menu\n        // /> and click on another <Menu /> which should close Menu A and open Menu B. We might\n        // revisit that so that you will require 2 clicks instead.\n        !ur(b, at.Loose) && // This could be improved, but the `Combobox.Button` adds tabIndex={-1} to make it\n        // unfocusable via the keyboard so that tabbing to the next item from the input doesn't\n        // first go to the button.\n        b.tabIndex !== -1 && f.preventDefault(), i(f, b)\n      );\n    }\n  }\n  const h = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  I(\"mousedown\", (f) => {\n    var m, d;\n    r.current && (h.current = ((d = (m = f.composedPath) == null ? void 0 : m.call(f)) == null ? void 0 : d[0]) || f.target);\n  }, !0), I(\n    \"click\",\n    (f) => {\n      h.current && (u(f, () => h.current), h.current = null);\n    },\n    // We will use the `capture` phase so that layers in between with `event.stopPropagation()`\n    // don't \"cancel\" this outside click check. E.g.: A `Menu` inside a `DialogPanel` if the `Menu`\n    // is open, and you click outside of it in the `DialogPanel` the `Menu` should close. However,\n    // the `DialogPanel` has a `onClick(e) { e.stopPropagation() }` which would cancel this.\n    !0\n  ), I(\"blur\", (f) => u(\n    f,\n    () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null\n  ), !0);\n}\nconst se = /* @__PURE__ */ new Map(), ke = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nke.displayName = \"ReferenceContext\";\nconst Ae = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nAe.displayName = \"FloatingContext\";\nconst te = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nte.displayName = \"ArrowContext\";\nfunction ut(t) {\n  const i = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ke);\n  if (i === null) {\n    const o = new Error(`<${t} /> is missing a parent <Float /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(o, ut), o;\n  }\n  return i;\n}\nfunction st(t) {\n  const i = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Ae);\n  if (i === null) {\n    const o = new Error(`<${t} /> is missing a parent <Float /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(o, st), o;\n  }\n  return i;\n}\nfunction ct(t) {\n  const i = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(te);\n  if (i === null) {\n    const o = new Error(`<${t} /> is missing a parent <Float /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(o, ct), o;\n  }\n  return i;\n}\nfunction lt(t, i, o, r) {\n  const { referenceRef: u } = r, h = i;\n  if (h.as === react__WEBPACK_IMPORTED_MODULE_0__.Fragment)\n    return /* @__PURE__ */ E.jsx(\n      t.type,\n      {\n        ...t.props,\n        ...o,\n        ref: u\n      }\n    );\n  const f = h.as || \"div\";\n  return /* @__PURE__ */ E.jsx(f, { ...o, ref: u, children: /* @__PURE__ */ E.jsx(t.type, { ...t.props }) });\n}\nfunction $e(t, i, o, r) {\n  const { floatingRef: u, props: h, mounted: f, setShow: m, x: d, y: b, placement: l, strategy: s, referenceElWidth: C } = r, y = {\n    ...h,\n    ...i\n  }, R = ar(y, l), O = {\n    show: f.current ? y.show : !1,\n    enter: `${y.enter || \"\"} ${R}`,\n    enterFrom: `${y.enterFrom || \"\"}`,\n    enterTo: `${y.enterTo || \"\"}`,\n    leave: `${y.leave || \"\"} ${R}`,\n    leaveFrom: `${y.leaveFrom || \"\"}`,\n    leaveTo: `${y.leaveTo || \"\"}`,\n    beforeEnter: () => {\n      m(!0);\n    },\n    afterLeave: () => {\n      m(!1);\n    }\n  }, W = {\n    style: {\n      // If enable dialog mode, then set `transform` to false.\n      ...!y.dialog && y.transform ? {\n        position: s,\n        zIndex: y.zIndex || 9999,\n        top: \"0px\",\n        left: \"0px\",\n        right: \"auto\",\n        bottom: \"auto\",\n        transform: `translate(${z(d || 0)}px,${z(b || 0)}px)`\n      } : {\n        position: s,\n        zIndex: y.zIndex || 9999,\n        top: `${z(b || 0)}px`,\n        left: `${z(d || 0)}px`\n      },\n      width: y.adaptiveWidth && typeof C == \"number\" ? `${C}px` : void 0\n    }\n  };\n  function A(F) {\n    return y.portal ? /* @__PURE__ */ E.jsx(_headlessui_react__WEBPACK_IMPORTED_MODULE_3__.Portal, { children: F }) : F;\n  }\n  function x(F) {\n    const N = {\n      ...W,\n      ...o,\n      ref: u\n    };\n    if (y.as === react__WEBPACK_IMPORTED_MODULE_0__.Fragment)\n      return /* @__PURE__ */ E.jsx(\n        F.type,\n        {\n          ...F.props,\n          ...N\n        }\n      );\n    const M = y.as || \"div\";\n    return /* @__PURE__ */ E.jsx(M, { ...N, children: /* @__PURE__ */ E.jsx(F.type, { ...F.props }) });\n  }\n  function Y() {\n    return q.isServer ? f.current && y.show ? /* @__PURE__ */ E.jsx(t.type, { ...t.props }) : /* @__PURE__ */ E.jsx(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, {}) : y.transitionChild ? /* @__PURE__ */ E.jsx(_headlessui_react__WEBPACK_IMPORTED_MODULE_4__.Transition.Child, { as: react__WEBPACK_IMPORTED_MODULE_0__.Fragment, ...O, children: /* @__PURE__ */ E.jsx(t.type, { ...t.props }) }) : /* @__PURE__ */ E.jsx(_headlessui_react__WEBPACK_IMPORTED_MODULE_4__.Transition, { as: react__WEBPACK_IMPORTED_MODULE_0__.Fragment, ...O, children: /* @__PURE__ */ E.jsx(t.type, { ...t.props }) });\n  }\n  return A(\n    x(\n      Y()\n    )\n  );\n}\nfunction ft([t, i], o) {\n  var J, G;\n  const r = rr(), u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1), [h, f] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(), m = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), d = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n    show: o.onShow || (() => {\n    }),\n    hide: o.onHide || (() => {\n    }),\n    update: o.onUpdate || (() => {\n    })\n  }), [o.onShow, o.onHide, o.onUpdate]), { x: b, y: l, placement: s, strategy: C, update: y, refs: R, middlewareData: O } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_5__.useFloating)({\n    placement: o.placement || \"bottom-start\",\n    strategy: o.strategy,\n    middleware: h\n  }), [W, A] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    u.current = !0;\n  }, []), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    t && !se.get(r) ? (se.set(r, !0), d.show()) : !t && se.get(r) && (se.delete(r), d.hide());\n  }, [t]);\n  const x = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    y(), d.update();\n  }, [y, d]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(x, [o.placement, o.strategy, h]), nr(f, R, m, o), or(o.adaptiveWidth, R.reference, A), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (R.reference.current && R.floating.current && t)\n      return o.autoUpdate !== !1 ? (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_6__.autoUpdate)(\n        R.reference.current,\n        R.floating.current,\n        x,\n        typeof o.autoUpdate == \"object\" ? o.autoUpdate : void 0\n      ) : () => {\n      };\n  }, [t, x, R]);\n  const Y = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!0);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    !(R.reference.current instanceof Element) && R.reference.current && R.floating.current && Y.current && (Y.current = !1, x(), window.requestAnimationFrame(() => {\n      Y.current = !0, x();\n    }));\n  }, [R]);\n  const F = {\n    referenceRef: R.setReference,\n    placement: s\n  }, N = {\n    floatingRef: R.setFloating,\n    props: o,\n    mounted: u,\n    setShow: i,\n    x: b,\n    y: l,\n    placement: s,\n    strategy: C,\n    referenceElWidth: W\n  }, M = {\n    arrowRef: m,\n    placement: s,\n    x: (J = O.arrow) == null ? void 0 : J.x,\n    y: (G = O.arrow) == null ? void 0 : G.y\n  };\n  return { referenceApi: F, floatingApi: N, arrowApi: M, x: b, y: l, placement: s, strategy: C, update: x, refs: R, middlewareData: O };\n}\nconst dt = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((t, i) => {\n  const [o, r] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(t.show ?? !1), {\n    referenceApi: u,\n    floatingApi: h,\n    arrowApi: f,\n    placement: m\n  } = ft([o, r], t), d = { placement: m }, [b, l] = typeof t.children == \"function\" ? t.children(d) : t.children;\n  if (!(0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(b))\n    return console.warn(\"<Float /> is missing a reference and floating element.\"), /* @__PURE__ */ E.jsx(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, {});\n  function s(R) {\n    if (t.as === react__WEBPACK_IMPORTED_MODULE_0__.Fragment || !t.as)\n      return /* @__PURE__ */ E.jsx(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: R });\n    const O = t.as;\n    return /* @__PURE__ */ E.jsx(O, { ref: i, className: t.className, children: R });\n  }\n  if (t.composable || t.dialog)\n    return s(\n      /* @__PURE__ */ E.jsx(ke.Provider, { value: u, children: /* @__PURE__ */ E.jsx(Ae.Provider, { value: h, children: /* @__PURE__ */ E.jsx(te.Provider, { value: f, children: typeof t.children == \"function\" ? t.children(d) : t.children }) }) }, \"FloatingNode\")\n    );\n  const C = lt(\n    b,\n    { as: react__WEBPACK_IMPORTED_MODULE_0__.Fragment },\n    { key: \"reference-node\" },\n    u\n  ), y = $e(\n    l,\n    { as: t.floatingAs || \"div\" },\n    {},\n    h\n  );\n  return s([\n    C,\n    /* @__PURE__ */ E.jsx(te.Provider, { value: f, children: y }, \"floating-node\")\n  ]);\n});\ndt.displayName = \"Float\";\nfunction lr(t) {\n  if (!t.children)\n    return /* @__PURE__ */ E.jsx(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, {});\n  const i = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const { as: h, children: f, ...m } = t;\n    return m;\n  }, [t]), o = ut(\"Float.Reference\"), { placement: r } = o, u = { placement: r };\n  return lt(\n    typeof t.children == \"function\" ? t.children(u) : t.children,\n    { ...t, as: t.as || react__WEBPACK_IMPORTED_MODULE_0__.Fragment },\n    i,\n    o\n  );\n}\nfunction fr(t) {\n  if (!t.children)\n    return /* @__PURE__ */ E.jsx(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, {});\n  const i = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const { as: h, enter: f, enterFrom: m, enterTo: d, leave: b, leaveFrom: l, leaveTo: s, originClass: C, tailwindcssOriginClass: y, transitionChild: R, children: O, ...W } = t;\n    return W;\n  }, [t]), o = st(\"Float.Content\"), { placement: r } = o, u = { placement: r };\n  return $e(\n    typeof t.children == \"function\" ? t.children(u) : t.children,\n    { ...t, as: t.as || \"div\" },\n    i,\n    o\n  );\n}\nfunction dr(t) {\n  const { arrowRef: i, placement: o, x: r, y: u } = ct(\"Float.Arrow\"), h = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const { as: b, offset: l, children: s, ...C } = t;\n    return C;\n  }, [t]), f = {\n    top: \"bottom\",\n    right: \"left\",\n    bottom: \"top\",\n    left: \"right\"\n  }[o.split(\"-\")[0]], m = {\n    left: typeof r == \"number\" ? `${z(r)}px` : void 0,\n    top: typeof u == \"number\" ? `${z(u)}px` : void 0,\n    right: void 0,\n    bottom: void 0,\n    [f]: `${(t.offset ?? 4) * -1}px`,\n    ...h.style\n  };\n  if (t.as === react__WEBPACK_IMPORTED_MODULE_0__.Fragment) {\n    const b = { placement: o }, l = typeof t.children == \"function\" ? t.children(b) : t.children;\n    return !l || !(0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(l) ? /* @__PURE__ */ E.jsx(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, {}) : /* @__PURE__ */ E.jsx(\n      l.type,\n      {\n        ...l.props,\n        ref: i,\n        style: m\n      }\n    );\n  }\n  const d = t.as || \"div\";\n  return /* @__PURE__ */ E.jsx(\n    d,\n    {\n      ref: i,\n      ...h,\n      style: m,\n      children: t.children\n    }\n  );\n}\nfunction Ie({ onInitial: t, children: i, ...o }) {\n  const [r, u] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(o.show ?? !1), h = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const { as: y, show: R, placement: O, strategy: W, offset: A, shift: x, flip: Y, arrow: F, autoPlacement: N, hide: M, autoUpdate: J, zIndex: G, enter: le, enterFrom: De, enterTo: We, leave: fe, leaveFrom: $, leaveTo: L, originClass: U, tailwindcssOriginClass: de, portal: ve, transform: he, middleware: ge, onShow: me, onHide: ye, onUpdate: be, ...re } = o;\n    return re;\n  }, [o]), {\n    floatingApi: f,\n    arrowApi: m,\n    placement: d,\n    refs: b\n  } = ft([r, u], o);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    u(o.show ?? !1);\n  }, [o.show]);\n  function l() {\n    r && u(!1);\n  }\n  if (t({ show: r, setShow: u, placement: d, refs: b }), !i)\n    return /* @__PURE__ */ E.jsx(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, {});\n  const C = $e(\n    typeof i == \"function\" ? i({ placement: d, close: l }) : i,\n    {\n      ...o,\n      as: o.as || react__WEBPACK_IMPORTED_MODULE_0__.Fragment,\n      show: r\n    },\n    h,\n    f\n  );\n  return /* @__PURE__ */ E.jsx(te.Provider, { value: m, children: C });\n}\nfunction vr(t) {\n  function i({ setShow: o, refs: r }) {\n    I(\"contextmenu\", (u) => {\n      u.preventDefault(), r.setPositionReference({\n        getBoundingClientRect() {\n          return {\n            width: 0,\n            height: 0,\n            x: u.clientX,\n            y: u.clientY,\n            top: u.clientY,\n            left: u.clientX,\n            right: u.clientX,\n            bottom: u.clientY\n          };\n        }\n      }), o(!0);\n    }), cr(r.floating, () => {\n      o(!1);\n    });\n  }\n  return /* @__PURE__ */ E.jsx(\n    Ie,\n    {\n      flip: !0,\n      ...t,\n      show: !1,\n      portal: !0,\n      onInitial: i\n    }\n  );\n}\nfunction hr({ globalHideCursor: t, ...i }) {\n  function o({ setShow: r, refs: u }) {\n    function h() {\n      r(!0);\n    }\n    function f() {\n      r(!1);\n    }\n    function m(s) {\n      u.setPositionReference({\n        getBoundingClientRect() {\n          return {\n            width: 0,\n            height: 0,\n            x: s.clientX,\n            y: s.clientY,\n            top: s.clientY,\n            left: s.clientX,\n            right: s.clientX,\n            bottom: s.clientY\n          };\n        }\n      });\n    }\n    function d(s) {\n      h(), m(s);\n    }\n    function b(s) {\n      h(), m(s.touches[0]);\n    }\n    const l = it(u.floating);\n    l && ((0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n      if ((t || t === void 0) && !l.getElementById(\"headlesui-float-cursor-style\")) {\n        const s = l.createElement(\"style\");\n        return (l.head || l.getElementsByTagName(\"head\")[0]).appendChild(s), s.id = \"headlesui-float-cursor-style\", s.appendChild(l.createTextNode([\n          \"*, *::before, *::after {\",\n          \"  cursor: none !important;\",\n          \"}\",\n          \".headlesui-float-cursor-root {\",\n          \"  pointer-events: none !important;\",\n          \"}\"\n        ].join(`\n`))), () => {\n          var y;\n          return (y = l.getElementById(\"headlesui-float-cursor-style\")) == null ? void 0 : y.remove();\n        };\n      }\n    }, [t]), \"ontouchstart\" in window || navigator.maxTouchPoints > 0 ? (I(\"touchstart\", b), I(\"touchend\", f), I(\"touchmove\", b)) : (I(\"mouseenter\", d), I(\"mouseleave\", f), I(\"mousemove\", d)));\n  }\n  return /* @__PURE__ */ E.jsx(\n    Ie,\n    {\n      ...i,\n      portal: !0,\n      className: \"headlesui-float-cursor-root\",\n      onInitial: o\n    }\n  );\n}\nconst xr = Object.assign(dt, { Reference: lr, Content: fr, Arrow: dr, Virtual: Ie, ContextMenu: vr, Cursor: hr });\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGhlYWRsZXNzdWktZmxvYXQvcmVhY3QvZGlzdC9oZWFkbGVzc3VpLWZsb2F0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLDBDQUEwQywwREFBMEQ7QUFDcEc7QUFDOE47QUFDM0o7QUFDQztBQUN3RDtBQUM1SCxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0NBQUUsNExBQTRMO0FBQ3hNO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsS0FBcUM7QUFDN0QsWUFBWSxrQ0FBRTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixPQUFPO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYixzQkFBc0I7QUFDdEI7QUFDQSxhQUFhO0FBQ2Isc0JBQXNCO0FBQ3RCO0FBQ0EsYUFBYTtBQUNiLHVCQUF1QjtBQUN2QjtBQUNBLGFBQWE7QUFDYix1QkFBdUI7QUFDdkI7QUFDQSxhQUFhO0FBQ2IsZ0NBQWdDO0FBQ2hDO0FBQ0EsYUFBYTtBQUNiLDBCQUEwQjtBQUMxQjtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG1DQUFtQztBQUMzRTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRjtBQUMvRjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdEQUFDO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLHFDQUFxQztBQUNyQyxZQUFZO0FBQ1oseUNBQXlDO0FBQ3pDLDZDQUE2QztBQUM3QyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUZBQWlGO0FBVTlHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0LXR3LW5leHQvLi9ub2RlX21vZHVsZXMvQGhlYWRsZXNzdWktZmxvYXQvcmVhY3QvZGlzdC9oZWFkbGVzc3VpLWZsb2F0Lm1qcz9lODdjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBZdCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBMdCA9ICh0LCBpLCBvKSA9PiBpIGluIHQgPyBZdCh0LCBpLCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiBvIH0pIDogdFtpXSA9IG87XG52YXIgamUgPSAodCwgaSwgbykgPT4gKEx0KHQsIHR5cGVvZiBpICE9IFwic3ltYm9sXCIgPyBpICsgXCJcIiA6IGksIG8pLCBvKTtcbmltcG9ydCBjZSwgeyB1c2VFZmZlY3QgYXMgUywgdXNlTGF5b3V0RWZmZWN0IGFzIE50LCB1c2VTdGF0ZSBhcyBlZSwgdXNlTWVtbyBhcyBYLCB1c2VSZWYgYXMgSCwgY3JlYXRlQ29udGV4dCBhcyBPZSwgRnJhZ21lbnQgYXMgaiwgZm9yd2FyZFJlZiBhcyBNdCwgaXNWYWxpZEVsZW1lbnQgYXMgcnQsIHVzZUNhbGxiYWNrIGFzIFV0LCB1c2VDb250ZXh0IGFzIEZlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBQb3J0YWwgYXMgVnQsIFRyYW5zaXRpb24gYXMgWmUgfSBmcm9tIFwiQGhlYWRsZXNzdWkvcmVhY3RcIjtcbmltcG9ydCB7IGFycm93IGFzIEJ0LCB1c2VGbG9hdGluZyBhcyB6dCB9IGZyb20gXCJAZmxvYXRpbmctdWkvcmVhY3RcIjtcbmltcG9ydCB7IG9mZnNldCBhcyBIdCwgZmxpcCBhcyBxdCwgc2hpZnQgYXMgWHQsIGF1dG9QbGFjZW1lbnQgYXMgSnQsIGhpZGUgYXMgR3QsIGF1dG9VcGRhdGUgYXMgS3QgfSBmcm9tIFwiQGZsb2F0aW5nLXVpL2RvbVwiO1xudmFyIFNlID0geyBleHBvcnRzOiB7fSB9LCBaID0ge307XG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtcnVudGltZS5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG52YXIgUWU7XG5mdW5jdGlvbiBadCgpIHtcbiAgaWYgKFFlKVxuICAgIHJldHVybiBaO1xuICBRZSA9IDE7XG4gIHZhciB0ID0gY2UsIGkgPSBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSwgbyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSwgciA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIHUgPSB0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELlJlYWN0Q3VycmVudE93bmVyLCBoID0geyBrZXk6ICEwLCByZWY6ICEwLCBfX3NlbGY6ICEwLCBfX3NvdXJjZTogITAgfTtcbiAgZnVuY3Rpb24gZihtLCBkLCBiKSB7XG4gICAgdmFyIGwsIHMgPSB7fSwgQyA9IG51bGwsIHkgPSBudWxsO1xuICAgIGIgIT09IHZvaWQgMCAmJiAoQyA9IFwiXCIgKyBiKSwgZC5rZXkgIT09IHZvaWQgMCAmJiAoQyA9IFwiXCIgKyBkLmtleSksIGQucmVmICE9PSB2b2lkIDAgJiYgKHkgPSBkLnJlZik7XG4gICAgZm9yIChsIGluIGQpXG4gICAgICByLmNhbGwoZCwgbCkgJiYgIWguaGFzT3duUHJvcGVydHkobCkgJiYgKHNbbF0gPSBkW2xdKTtcbiAgICBpZiAobSAmJiBtLmRlZmF1bHRQcm9wcylcbiAgICAgIGZvciAobCBpbiBkID0gbS5kZWZhdWx0UHJvcHMsIGQpXG4gICAgICAgIHNbbF0gPT09IHZvaWQgMCAmJiAoc1tsXSA9IGRbbF0pO1xuICAgIHJldHVybiB7ICQkdHlwZW9mOiBpLCB0eXBlOiBtLCBrZXk6IEMsIHJlZjogeSwgcHJvcHM6IHMsIF9vd25lcjogdS5jdXJyZW50IH07XG4gIH1cbiAgcmV0dXJuIFouRnJhZ21lbnQgPSBvLCBaLmpzeCA9IGYsIFouanN4cyA9IGYsIFo7XG59XG52YXIgUSA9IHt9O1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIGV0O1xuZnVuY3Rpb24gUXQoKSB7XG4gIHJldHVybiBldCB8fCAoZXQgPSAxLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSBjZSwgaSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpLCBvID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSwgciA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSwgdSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSwgaCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSwgZiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKSwgbSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLCBkID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLCBiID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLCBsID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksIHMgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSwgQyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLCB5ID0gU3ltYm9sLmZvcihcInJlYWN0Lm9mZnNjcmVlblwiKSwgUiA9IFN5bWJvbC5pdGVyYXRvciwgTyA9IFwiQEBpdGVyYXRvclwiO1xuICAgIGZ1bmN0aW9uIFcoZSkge1xuICAgICAgaWYgKGUgPT09IG51bGwgfHwgdHlwZW9mIGUgIT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgbiA9IFIgJiYgZVtSXSB8fCBlW09dO1xuICAgICAgcmV0dXJuIHR5cGVvZiBuID09IFwiZnVuY3Rpb25cIiA/IG4gOiBudWxsO1xuICAgIH1cbiAgICB2YXIgQSA9IHQuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG4gICAgZnVuY3Rpb24geChlKSB7XG4gICAgICB7XG4gICAgICAgIGZvciAodmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoLCBhID0gbmV3IEFycmF5KG4gPiAxID8gbiAtIDEgOiAwKSwgYyA9IDE7IGMgPCBuOyBjKyspXG4gICAgICAgICAgYVtjIC0gMV0gPSBhcmd1bWVudHNbY107XG4gICAgICAgIFkoXCJlcnJvclwiLCBlLCBhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gWShlLCBuLCBhKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBjID0gQS5SZWFjdERlYnVnQ3VycmVudEZyYW1lLCBwID0gYy5nZXRTdGFja0FkZGVuZHVtKCk7XG4gICAgICAgIHAgIT09IFwiXCIgJiYgKG4gKz0gXCIlc1wiLCBhID0gYS5jb25jYXQoW3BdKSk7XG4gICAgICAgIHZhciB3ID0gYS5tYXAoZnVuY3Rpb24oZykge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcoZyk7XG4gICAgICAgIH0pO1xuICAgICAgICB3LnVuc2hpZnQoXCJXYXJuaW5nOiBcIiArIG4pLCBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2VdLCBjb25zb2xlLCB3KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIEYgPSAhMSwgTiA9ICExLCBNID0gITEsIEogPSAhMSwgRyA9ICExLCBsZTtcbiAgICBsZSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tb2R1bGUucmVmZXJlbmNlXCIpO1xuICAgIGZ1bmN0aW9uIERlKGUpIHtcbiAgICAgIHJldHVybiAhISh0eXBlb2YgZSA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiB8fCBlID09PSByIHx8IGUgPT09IGggfHwgRyB8fCBlID09PSB1IHx8IGUgPT09IGIgfHwgZSA9PT0gbCB8fCBKIHx8IGUgPT09IHkgfHwgRiB8fCBOIHx8IE0gfHwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiAmJiBlICE9PSBudWxsICYmIChlLiQkdHlwZW9mID09PSBDIHx8IGUuJCR0eXBlb2YgPT09IHMgfHwgZS4kJHR5cGVvZiA9PT0gZiB8fCBlLiQkdHlwZW9mID09PSBtIHx8IGUuJCR0eXBlb2YgPT09IGQgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgICAvLyB3aXRoLlxuICAgICAgZS4kJHR5cGVvZiA9PT0gbGUgfHwgZS5nZXRNb2R1bGVJZCAhPT0gdm9pZCAwKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdlKGUsIG4sIGEpIHtcbiAgICAgIHZhciBjID0gZS5kaXNwbGF5TmFtZTtcbiAgICAgIGlmIChjKVxuICAgICAgICByZXR1cm4gYztcbiAgICAgIHZhciBwID0gbi5kaXNwbGF5TmFtZSB8fCBuLm5hbWUgfHwgXCJcIjtcbiAgICAgIHJldHVybiBwICE9PSBcIlwiID8gYSArIFwiKFwiICsgcCArIFwiKVwiIDogYTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmUoZSkge1xuICAgICAgcmV0dXJuIGUuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uICQoZSkge1xuICAgICAgaWYgKGUgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBpZiAodHlwZW9mIGUudGFnID09IFwibnVtYmVyXCIgJiYgeChcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIpLCB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiBlLmRpc3BsYXlOYW1lIHx8IGUubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBlO1xuICAgICAgc3dpdGNoIChlKSB7XG4gICAgICAgIGNhc2UgcjpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIG86XG4gICAgICAgICAgcmV0dXJuIFwiUG9ydGFsXCI7XG4gICAgICAgIGNhc2UgaDpcbiAgICAgICAgICByZXR1cm4gXCJQcm9maWxlclwiO1xuICAgICAgICBjYXNlIHU6XG4gICAgICAgICAgcmV0dXJuIFwiU3RyaWN0TW9kZVwiO1xuICAgICAgICBjYXNlIGI6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSBsOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlID09IFwib2JqZWN0XCIpXG4gICAgICAgIHN3aXRjaCAoZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgbTpcbiAgICAgICAgICAgIHZhciBuID0gZTtcbiAgICAgICAgICAgIHJldHVybiBmZShuKSArIFwiLkNvbnN1bWVyXCI7XG4gICAgICAgICAgY2FzZSBmOlxuICAgICAgICAgICAgdmFyIGEgPSBlO1xuICAgICAgICAgICAgcmV0dXJuIGZlKGEuX2NvbnRleHQpICsgXCIuUHJvdmlkZXJcIjtcbiAgICAgICAgICBjYXNlIGQ6XG4gICAgICAgICAgICByZXR1cm4gV2UoZSwgZS5yZW5kZXIsIFwiRm9yd2FyZFJlZlwiKTtcbiAgICAgICAgICBjYXNlIHM6XG4gICAgICAgICAgICB2YXIgYyA9IGUuZGlzcGxheU5hbWUgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBjICE9PSBudWxsID8gYyA6ICQoZS50eXBlKSB8fCBcIk1lbW9cIjtcbiAgICAgICAgICBjYXNlIEM6IHtcbiAgICAgICAgICAgIHZhciBwID0gZSwgdyA9IHAuX3BheWxvYWQsIGcgPSBwLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuICQoZyh3KSk7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIEwgPSBPYmplY3QuYXNzaWduLCBVID0gMCwgZGUsIHZlLCBoZSwgZ2UsIG1lLCB5ZSwgYmU7XG4gICAgZnVuY3Rpb24gcmUoKSB7XG4gICAgfVxuICAgIHJlLl9fcmVhY3REaXNhYmxlZExvZyA9ICEwO1xuICAgIGZ1bmN0aW9uIHZ0KCkge1xuICAgICAge1xuICAgICAgICBpZiAoVSA9PT0gMCkge1xuICAgICAgICAgIGRlID0gY29uc29sZS5sb2csIHZlID0gY29uc29sZS5pbmZvLCBoZSA9IGNvbnNvbGUud2FybiwgZ2UgPSBjb25zb2xlLmVycm9yLCBtZSA9IGNvbnNvbGUuZ3JvdXAsIHllID0gY29uc29sZS5ncm91cENvbGxhcHNlZCwgYmUgPSBjb25zb2xlLmdyb3VwRW5kO1xuICAgICAgICAgIHZhciBlID0ge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgdmFsdWU6IHJlLFxuICAgICAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgICBpbmZvOiBlLFxuICAgICAgICAgICAgbG9nOiBlLFxuICAgICAgICAgICAgd2FybjogZSxcbiAgICAgICAgICAgIGVycm9yOiBlLFxuICAgICAgICAgICAgZ3JvdXA6IGUsXG4gICAgICAgICAgICBncm91cENvbGxhcHNlZDogZSxcbiAgICAgICAgICAgIGdyb3VwRW5kOiBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgVSsrO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBodCgpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKFUtLSwgVSA9PT0gMCkge1xuICAgICAgICAgIHZhciBlID0ge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgICBsb2c6IEwoe30sIGUsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGRlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGluZm86IEwoe30sIGUsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHZlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHdhcm46IEwoe30sIGUsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGhlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGVycm9yOiBMKHt9LCBlLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBnZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBncm91cDogTCh7fSwgZSwge1xuICAgICAgICAgICAgICB2YWx1ZTogbWVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IEwoe30sIGUsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHllXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdyb3VwRW5kOiBMKHt9LCBlLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBiZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBVIDwgMCAmJiB4KFwiZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHBlID0gQS5SZWFjdEN1cnJlbnREaXNwYXRjaGVyLCBFZTtcbiAgICBmdW5jdGlvbiBuZShlLCBuLCBhKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChFZSA9PT0gdm9pZCAwKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHApIHtcbiAgICAgICAgICAgIHZhciBjID0gcC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgICAgIEVlID0gYyAmJiBjWzFdIHx8IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFxuYCArIEVlICsgZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHdlID0gITEsIG9lO1xuICAgIHtcbiAgICAgIHZhciBndCA9IHR5cGVvZiBXZWFrTWFwID09IFwiZnVuY3Rpb25cIiA/IFdlYWtNYXAgOiBNYXA7XG4gICAgICBvZSA9IG5ldyBndCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBZZShlLCBuKSB7XG4gICAgICBpZiAoIWUgfHwgd2UpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAge1xuICAgICAgICB2YXIgYSA9IG9lLmdldChlKTtcbiAgICAgICAgaWYgKGEgIT09IHZvaWQgMClcbiAgICAgICAgICByZXR1cm4gYTtcbiAgICAgIH1cbiAgICAgIHZhciBjO1xuICAgICAgd2UgPSAhMDtcbiAgICAgIHZhciBwID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHZvaWQgMDtcbiAgICAgIHZhciB3O1xuICAgICAgdyA9IHBlLmN1cnJlbnQsIHBlLmN1cnJlbnQgPSBudWxsLCB2dCgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICB2YXIgZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkoZy5wcm90b3R5cGUsIFwicHJvcHNcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgdHlwZW9mIFJlZmxlY3QgPT0gXCJvYmplY3RcIiAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZywgW10pO1xuICAgICAgICAgICAgfSBjYXRjaCAoRCkge1xuICAgICAgICAgICAgICBjID0gRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGUsIFtdLCBnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZy5jYWxsKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChEKSB7XG4gICAgICAgICAgICAgIGMgPSBEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZS5jYWxsKGcucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoRCkge1xuICAgICAgICAgICAgYyA9IEQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGUoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoRCkge1xuICAgICAgICBpZiAoRCAmJiBjICYmIHR5cGVvZiBELnN0YWNrID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBmb3IgKHZhciB2ID0gRC5zdGFjay5zcGxpdChgXG5gKSwgUCA9IGMuc3RhY2suc3BsaXQoYFxuYCksIF8gPSB2Lmxlbmd0aCAtIDEsIFQgPSBQLmxlbmd0aCAtIDE7IF8gPj0gMSAmJiBUID49IDAgJiYgdltfXSAhPT0gUFtUXTsgKVxuICAgICAgICAgICAgVC0tO1xuICAgICAgICAgIGZvciAoOyBfID49IDEgJiYgVCA+PSAwOyBfLS0sIFQtLSlcbiAgICAgICAgICAgIGlmICh2W19dICE9PSBQW1RdKSB7XG4gICAgICAgICAgICAgIGlmIChfICE9PSAxIHx8IFQgIT09IDEpXG4gICAgICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgICAgIGlmIChfLS0sIFQtLSwgVCA8IDAgfHwgdltfXSAhPT0gUFtUXSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgayA9IGBcbmAgKyB2W19dLnJlcGxhY2UoXCIgYXQgbmV3IFwiLCBcIiBhdCBcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmRpc3BsYXlOYW1lICYmIGsuaW5jbHVkZXMoXCI8YW5vbnltb3VzPlwiKSAmJiAoayA9IGsucmVwbGFjZShcIjxhbm9ueW1vdXM+XCIsIGUuZGlzcGxheU5hbWUpKSwgdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiICYmIG9lLnNldChlLCBrKSwgaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoXyA+PSAxICYmIFQgPj0gMCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB3ZSA9ICExLCBwZS5jdXJyZW50ID0gdywgaHQoKSwgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwO1xuICAgICAgfVxuICAgICAgdmFyIEIgPSBlID8gZS5kaXNwbGF5TmFtZSB8fCBlLm5hbWUgOiBcIlwiLCBLZSA9IEIgPyBuZShCKSA6IFwiXCI7XG4gICAgICByZXR1cm4gdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiICYmIG9lLnNldChlLCBLZSksIEtlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtdChlLCBuLCBhKSB7XG4gICAgICByZXR1cm4gWWUoZSwgITEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB5dChlKSB7XG4gICAgICB2YXIgbiA9IGUucHJvdG90eXBlO1xuICAgICAgcmV0dXJuICEhKG4gJiYgbi5pc1JlYWN0Q29tcG9uZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaWUoZSwgbiwgYSkge1xuICAgICAgaWYgKGUgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICBpZiAodHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZXR1cm4gWWUoZSwgeXQoZSkpO1xuICAgICAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBuZShlKTtcbiAgICAgIHN3aXRjaCAoZSkge1xuICAgICAgICBjYXNlIGI6XG4gICAgICAgICAgcmV0dXJuIG5lKFwiU3VzcGVuc2VcIik7XG4gICAgICAgIGNhc2UgbDpcbiAgICAgICAgICByZXR1cm4gbmUoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGUgPT0gXCJvYmplY3RcIilcbiAgICAgICAgc3dpdGNoIChlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBkOlxuICAgICAgICAgICAgcmV0dXJuIG10KGUucmVuZGVyKTtcbiAgICAgICAgICBjYXNlIHM6XG4gICAgICAgICAgICByZXR1cm4gaWUoZS50eXBlLCBuLCBhKTtcbiAgICAgICAgICBjYXNlIEM6IHtcbiAgICAgICAgICAgIHZhciBjID0gZSwgcCA9IGMuX3BheWxvYWQsIHcgPSBjLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGllKHcocCksIG4sIGEpO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgdmFyIGFlID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgTGUgPSB7fSwgTmUgPSBBLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgZnVuY3Rpb24gdWUoZSkge1xuICAgICAgaWYgKGUpIHtcbiAgICAgICAgdmFyIG4gPSBlLl9vd25lciwgYSA9IGllKGUudHlwZSwgZS5fc291cmNlLCBuID8gbi50eXBlIDogbnVsbCk7XG4gICAgICAgIE5lLnNldEV4dHJhU3RhY2tGcmFtZShhKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBOZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJ0KGUsIG4sIGEsIGMsIHApIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHcgPSBGdW5jdGlvbi5jYWxsLmJpbmQoYWUpO1xuICAgICAgICBmb3IgKHZhciBnIGluIGUpXG4gICAgICAgICAgaWYgKHcoZSwgZykpIHtcbiAgICAgICAgICAgIHZhciB2ID0gdm9pZCAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlW2ddICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHZhciBQID0gRXJyb3IoKGMgfHwgXCJSZWFjdCBjbGFzc1wiKSArIFwiOiBcIiArIGEgKyBcIiB0eXBlIGBcIiArIGcgKyBcImAgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYFwiICsgdHlwZW9mIGVbZ10gKyBcImAuVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuXCIpO1xuICAgICAgICAgICAgICAgIHRocm93IFAubmFtZSA9IFwiSW52YXJpYW50IFZpb2xhdGlvblwiLCBQO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHYgPSBlW2ddKG4sIGcsIGMsIGEsIG51bGwsIFwiU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRURcIik7XG4gICAgICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgIHYgPSBfO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdiAmJiAhKHYgaW5zdGFuY2VvZiBFcnJvcikgJiYgKHVlKHApLCB4KFwiJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuIFlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyIGNyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLlwiLCBjIHx8IFwiUmVhY3QgY2xhc3NcIiwgYSwgZywgdHlwZW9mIHYpLCB1ZShudWxsKSksIHYgaW5zdGFuY2VvZiBFcnJvciAmJiAhKHYubWVzc2FnZSBpbiBMZSkgJiYgKExlW3YubWVzc2FnZV0gPSAhMCwgdWUocCksIHgoXCJGYWlsZWQgJXMgdHlwZTogJXNcIiwgYSwgdi5tZXNzYWdlKSwgdWUobnVsbCkpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHB0ID0gQXJyYXkuaXNBcnJheTtcbiAgICBmdW5jdGlvbiBSZShlKSB7XG4gICAgICByZXR1cm4gcHQoZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEV0KGUpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIG4gPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wudG9TdHJpbmdUYWcsIGEgPSBuICYmIGVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCBlLmNvbnN0cnVjdG9yLm5hbWUgfHwgXCJPYmplY3RcIjtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHd0KGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBNZShlKSwgITE7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBNZShlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVlKGUpIHtcbiAgICAgIGlmICh3dChlKSlcbiAgICAgICAgcmV0dXJuIHgoXCJUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIiwgRXQoZSkpLCBNZShlKTtcbiAgICB9XG4gICAgdmFyIEsgPSBBLlJlYWN0Q3VycmVudE93bmVyLCBSdCA9IHtcbiAgICAgIGtleTogITAsXG4gICAgICByZWY6ICEwLFxuICAgICAgX19zZWxmOiAhMCxcbiAgICAgIF9fc291cmNlOiAhMFxuICAgIH0sIFZlLCBCZSwgeGU7XG4gICAgeGUgPSB7fTtcbiAgICBmdW5jdGlvbiB4dChlKSB7XG4gICAgICBpZiAoYWUuY2FsbChlLCBcInJlZlwiKSkge1xuICAgICAgICB2YXIgbiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgXCJyZWZcIikuZ2V0O1xuICAgICAgICBpZiAobiAmJiBuLmlzUmVhY3RXYXJuaW5nKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlLnJlZiAhPT0gdm9pZCAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBDdChlKSB7XG4gICAgICBpZiAoYWUuY2FsbChlLCBcImtleVwiKSkge1xuICAgICAgICB2YXIgbiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgXCJrZXlcIikuZ2V0O1xuICAgICAgICBpZiAobiAmJiBuLmlzUmVhY3RXYXJuaW5nKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlLmtleSAhPT0gdm9pZCAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfdChlLCBuKSB7XG4gICAgICBpZiAodHlwZW9mIGUucmVmID09IFwic3RyaW5nXCIgJiYgSy5jdXJyZW50ICYmIG4gJiYgSy5jdXJyZW50LnN0YXRlTm9kZSAhPT0gbikge1xuICAgICAgICB2YXIgYSA9ICQoSy5jdXJyZW50LnR5cGUpO1xuICAgICAgICB4ZVthXSB8fCAoeCgnQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuIFN1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiBXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsICQoSy5jdXJyZW50LnR5cGUpLCBlLnJlZiksIHhlW2FdID0gITApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBUdChlLCBuKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgVmUgfHwgKFZlID0gITAsIHgoXCIlczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lIHZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgcHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKVwiLCBuKSk7XG4gICAgICAgIH07XG4gICAgICAgIGEuaXNSZWFjdFdhcm5pbmcgPSAhMCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwia2V5XCIsIHtcbiAgICAgICAgICBnZXQ6IGEsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24ganQoZSwgbikge1xuICAgICAge1xuICAgICAgICB2YXIgYSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIEJlIHx8IChCZSA9ICEwLCB4KFwiJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcylcIiwgbikpO1xuICAgICAgICB9O1xuICAgICAgICBhLmlzUmVhY3RXYXJuaW5nID0gITAsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInJlZlwiLCB7XG4gICAgICAgICAgZ2V0OiBhLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBQdCA9IGZ1bmN0aW9uKGUsIG4sIGEsIGMsIHAsIHcsIGcpIHtcbiAgICAgIHZhciB2ID0ge1xuICAgICAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAgICAgJCR0eXBlb2Y6IGksXG4gICAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgICAgdHlwZTogZSxcbiAgICAgICAga2V5OiBuLFxuICAgICAgICByZWY6IGEsXG4gICAgICAgIHByb3BzOiBnLFxuICAgICAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgICAgICBfb3duZXI6IHdcbiAgICAgIH07XG4gICAgICByZXR1cm4gdi5fc3RvcmUgPSB7fSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHYuX3N0b3JlLCBcInZhbGlkYXRlZFwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiAhMVxuICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2LCBcIl9zZWxmXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMSxcbiAgICAgICAgdmFsdWU6IGNcbiAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodiwgXCJfc291cmNlXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMSxcbiAgICAgICAgdmFsdWU6IHBcbiAgICAgIH0pLCBPYmplY3QuZnJlZXplICYmIChPYmplY3QuZnJlZXplKHYucHJvcHMpLCBPYmplY3QuZnJlZXplKHYpKSwgdjtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIFN0KGUsIG4sIGEsIGMsIHApIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHcsIGcgPSB7fSwgdiA9IG51bGwsIFAgPSBudWxsO1xuICAgICAgICBhICE9PSB2b2lkIDAgJiYgKFVlKGEpLCB2ID0gXCJcIiArIGEpLCBDdChuKSAmJiAoVWUobi5rZXkpLCB2ID0gXCJcIiArIG4ua2V5KSwgeHQobikgJiYgKFAgPSBuLnJlZiwgX3QobiwgcCkpO1xuICAgICAgICBmb3IgKHcgaW4gbilcbiAgICAgICAgICBhZS5jYWxsKG4sIHcpICYmICFSdC5oYXNPd25Qcm9wZXJ0eSh3KSAmJiAoZ1t3XSA9IG5bd10pO1xuICAgICAgICBpZiAoZSAmJiBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgICAgIHZhciBfID0gZS5kZWZhdWx0UHJvcHM7XG4gICAgICAgICAgZm9yICh3IGluIF8pXG4gICAgICAgICAgICBnW3ddID09PSB2b2lkIDAgJiYgKGdbd10gPSBfW3ddKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodiB8fCBQKSB7XG4gICAgICAgICAgdmFyIFQgPSB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBlLmRpc3BsYXlOYW1lIHx8IGUubmFtZSB8fCBcIlVua25vd25cIiA6IGU7XG4gICAgICAgICAgdiAmJiBUdChnLCBUKSwgUCAmJiBqdChnLCBUKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHQoZSwgdiwgUCwgcCwgYywgSy5jdXJyZW50LCBnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIENlID0gQS5SZWFjdEN1cnJlbnRPd25lciwgemUgPSBBLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgZnVuY3Rpb24gVihlKSB7XG4gICAgICBpZiAoZSkge1xuICAgICAgICB2YXIgbiA9IGUuX293bmVyLCBhID0gaWUoZS50eXBlLCBlLl9zb3VyY2UsIG4gPyBuLnR5cGUgOiBudWxsKTtcbiAgICAgICAgemUuc2V0RXh0cmFTdGFja0ZyYW1lKGEpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHplLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gICAgdmFyIF9lO1xuICAgIF9lID0gITE7XG4gICAgZnVuY3Rpb24gVGUoZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgZSAhPT0gbnVsbCAmJiBlLiQkdHlwZW9mID09PSBpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBIZSgpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKENlLmN1cnJlbnQpIHtcbiAgICAgICAgICB2YXIgZSA9ICQoQ2UuY3VycmVudC50eXBlKTtcbiAgICAgICAgICBpZiAoZSlcbiAgICAgICAgICAgIHJldHVybiBgXG5cbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIFxcYGAgKyBlICsgXCJgLlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBPdChlKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICB2YXIgbiA9IGUuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgXCJcIiksIGEgPSBlLmxpbmVOdW1iZXI7XG4gICAgICAgICAgcmV0dXJuIGBcblxuQ2hlY2sgeW91ciBjb2RlIGF0IGAgKyBuICsgXCI6XCIgKyBhICsgXCIuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBxZSA9IHt9O1xuICAgIGZ1bmN0aW9uIEZ0KGUpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIG4gPSBIZSgpO1xuICAgICAgICBpZiAoIW4pIHtcbiAgICAgICAgICB2YXIgYSA9IHR5cGVvZiBlID09IFwic3RyaW5nXCIgPyBlIDogZS5kaXNwbGF5TmFtZSB8fCBlLm5hbWU7XG4gICAgICAgICAgYSAmJiAobiA9IGBcblxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8YCArIGEgKyBcIj4uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBYZShlLCBuKSB7XG4gICAgICB7XG4gICAgICAgIGlmICghZS5fc3RvcmUgfHwgZS5fc3RvcmUudmFsaWRhdGVkIHx8IGUua2V5ICE9IG51bGwpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBlLl9zdG9yZS52YWxpZGF0ZWQgPSAhMDtcbiAgICAgICAgdmFyIGEgPSBGdChuKTtcbiAgICAgICAgaWYgKHFlW2FdKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcWVbYV0gPSAhMDtcbiAgICAgICAgdmFyIGMgPSBcIlwiO1xuICAgICAgICBlICYmIGUuX293bmVyICYmIGUuX293bmVyICE9PSBDZS5jdXJyZW50ICYmIChjID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyAkKGUuX293bmVyLnR5cGUpICsgXCIuXCIpLCBWKGUpLCB4KCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBhLCBjKSwgVihudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gSmUoZSwgbikge1xuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIGUgIT0gXCJvYmplY3RcIilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChSZShlKSlcbiAgICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IGUubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgICAgIHZhciBjID0gZVthXTtcbiAgICAgICAgICAgIFRlKGMpICYmIFhlKGMsIG4pO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVGUoZSkpXG4gICAgICAgICAgZS5fc3RvcmUgJiYgKGUuX3N0b3JlLnZhbGlkYXRlZCA9ICEwKTtcbiAgICAgICAgZWxzZSBpZiAoZSkge1xuICAgICAgICAgIHZhciBwID0gVyhlKTtcbiAgICAgICAgICBpZiAodHlwZW9mIHAgPT0gXCJmdW5jdGlvblwiICYmIHAgIT09IGUuZW50cmllcylcbiAgICAgICAgICAgIGZvciAodmFyIHcgPSBwLmNhbGwoZSksIGc7ICEoZyA9IHcubmV4dCgpKS5kb25lOyApXG4gICAgICAgICAgICAgIFRlKGcudmFsdWUpICYmIFhlKGcudmFsdWUsIG4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGt0KGUpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIG4gPSBlLnR5cGU7XG4gICAgICAgIGlmIChuID09IG51bGwgfHwgdHlwZW9mIG4gPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBhO1xuICAgICAgICBpZiAodHlwZW9mIG4gPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIGEgPSBuLnByb3BUeXBlcztcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG4gPT0gXCJvYmplY3RcIiAmJiAobi4kJHR5cGVvZiA9PT0gZCB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgICAgICBuLiQkdHlwZW9mID09PSBzKSlcbiAgICAgICAgICBhID0gbi5wcm9wVHlwZXM7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChhKSB7XG4gICAgICAgICAgdmFyIGMgPSAkKG4pO1xuICAgICAgICAgIGJ0KGEsIGUucHJvcHMsIFwicHJvcFwiLCBjLCBlKTtcbiAgICAgICAgfSBlbHNlIGlmIChuLlByb3BUeXBlcyAhPT0gdm9pZCAwICYmICFfZSkge1xuICAgICAgICAgIF9lID0gITA7XG4gICAgICAgICAgdmFyIHAgPSAkKG4pO1xuICAgICAgICAgIHgoXCJDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD9cIiwgcCB8fCBcIlVua25vd25cIik7XG4gICAgICAgIH1cbiAgICAgICAgdHlwZW9mIG4uZ2V0RGVmYXVsdFByb3BzID09IFwiZnVuY3Rpb25cIiAmJiAhbi5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQgJiYgeChcImdldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyBkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBBdChlKSB7XG4gICAgICB7XG4gICAgICAgIGZvciAodmFyIG4gPSBPYmplY3Qua2V5cyhlLnByb3BzKSwgYSA9IDA7IGEgPCBuLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgICAgdmFyIGMgPSBuW2FdO1xuICAgICAgICAgIGlmIChjICE9PSBcImNoaWxkcmVuXCIgJiYgYyAhPT0gXCJrZXlcIikge1xuICAgICAgICAgICAgVihlKSwgeChcIkludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuIFJlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuXCIsIGMpLCBWKG51bGwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGUucmVmICE9PSBudWxsICYmIChWKGUpLCB4KFwiSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC5cIiksIFYobnVsbCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBHZShlLCBuLCBhLCBjLCBwLCB3KSB7XG4gICAgICB7XG4gICAgICAgIHZhciBnID0gRGUoZSk7XG4gICAgICAgIGlmICghZykge1xuICAgICAgICAgIHZhciB2ID0gXCJcIjtcbiAgICAgICAgICAoZSA9PT0gdm9pZCAwIHx8IHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyhlKS5sZW5ndGggPT09IDApICYmICh2ICs9IFwiIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlIGl0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIik7XG4gICAgICAgICAgdmFyIFAgPSBPdChwKTtcbiAgICAgICAgICBQID8gdiArPSBQIDogdiArPSBIZSgpO1xuICAgICAgICAgIHZhciBfO1xuICAgICAgICAgIGUgPT09IG51bGwgPyBfID0gXCJudWxsXCIgOiBSZShlKSA/IF8gPSBcImFycmF5XCIgOiBlICE9PSB2b2lkIDAgJiYgZS4kJHR5cGVvZiA9PT0gaSA/IChfID0gXCI8XCIgKyAoJChlLnR5cGUpIHx8IFwiVW5rbm93blwiKSArIFwiIC8+XCIsIHYgPSBcIiBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50P1wiKSA6IF8gPSB0eXBlb2YgZSwgeChcIlJlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lc1wiLCBfLCB2KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgVCA9IFN0KGUsIG4sIGEsIHAsIHcpO1xuICAgICAgICBpZiAoVCA9PSBudWxsKVxuICAgICAgICAgIHJldHVybiBUO1xuICAgICAgICBpZiAoZykge1xuICAgICAgICAgIHZhciBrID0gbi5jaGlsZHJlbjtcbiAgICAgICAgICBpZiAoayAhPT0gdm9pZCAwKVxuICAgICAgICAgICAgaWYgKGMpXG4gICAgICAgICAgICAgIGlmIChSZShrKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIEIgPSAwOyBCIDwgay5sZW5ndGg7IEIrKylcbiAgICAgICAgICAgICAgICAgIEplKGtbQl0sIGUpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5mcmVlemUgJiYgT2JqZWN0LmZyZWV6ZShrKTtcbiAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgeChcIlJlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuIFlvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC5cIik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIEplKGssIGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlID09PSByID8gQXQoVCkgOiBrdChUKSwgVDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gJHQoZSwgbiwgYSkge1xuICAgICAgcmV0dXJuIEdlKGUsIG4sIGEsICEwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXQoZSwgbiwgYSkge1xuICAgICAgcmV0dXJuIEdlKGUsIG4sIGEsICExKTtcbiAgICB9XG4gICAgdmFyIER0ID0gSXQsIFd0ID0gJHQ7XG4gICAgUS5GcmFnbWVudCA9IHIsIFEuanN4ID0gRHQsIFEuanN4cyA9IFd0O1xuICB9KCkpLCBRO1xufVxucHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gU2UuZXhwb3J0cyA9IFp0KCkgOiBTZS5leHBvcnRzID0gUXQoKTtcbnZhciBFID0gU2UuZXhwb3J0cztcbmZ1bmN0aW9uIHoodCkge1xuICBjb25zdCBpID0gdHlwZW9mIHdpbmRvdyA8IFwidVwiID8gd2luZG93LmRldmljZVBpeGVsUmF0aW8gOiAxO1xuICByZXR1cm4gTWF0aC5yb3VuZCh0ICogaSkgLyBpO1xufVxuY2xhc3MgZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBqZSh0aGlzLCBcImN1cnJlbnRcIiwgdGhpcy5kZXRlY3QoKSk7XG4gICAgamUodGhpcywgXCJjdXJyZW50SWRcIiwgMCk7XG4gIH1cbiAgc2V0KGkpIHtcbiAgICB0aGlzLmN1cnJlbnQgIT09IGkgJiYgKHRoaXMuY3VycmVudElkID0gMCwgdGhpcy5jdXJyZW50ID0gaSk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5zZXQodGhpcy5kZXRlY3QoKSk7XG4gIH1cbiAgbmV4dElkKCkge1xuICAgIHJldHVybiArK3RoaXMuY3VycmVudElkO1xuICB9XG4gIGdldCBpc1NlcnZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50ID09PSBcInNlcnZlclwiO1xuICB9XG4gIGdldCBpc0NsaWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50ID09PSBcImNsaWVudFwiO1xuICB9XG4gIGRldGVjdCgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyA+IFwidVwiIHx8IHR5cGVvZiBkb2N1bWVudCA+IFwidVwiID8gXCJzZXJ2ZXJcIiA6IFwiY2xpZW50XCI7XG4gIH1cbn1cbmNvbnN0IHEgPSBuZXcgZXIoKSwgbnQgPSAodCwgaSkgPT4ge1xuICBxLmlzU2VydmVyID8gUyh0LCBpKSA6IE50KHQsIGkpO1xufSwgUGUgPSB7IHNlcnZlckhhbmRvZmZDb21wbGV0ZTogITEgfTtcbmZ1bmN0aW9uIHRyKCkge1xuICBjb25zdCBbdCwgaV0gPSBlZShQZS5zZXJ2ZXJIYW5kb2ZmQ29tcGxldGUpO1xuICByZXR1cm4gUygoKSA9PiB7XG4gICAgdCAhPT0gITAgJiYgaSghMCk7XG4gIH0sIFt0XSksIFMoKCkgPT4ge1xuICAgIFBlLnNlcnZlckhhbmRvZmZDb21wbGV0ZSA9PT0gITEgJiYgKFBlLnNlcnZlckhhbmRvZmZDb21wbGV0ZSA9ICEwKTtcbiAgfSwgW10pLCB0O1xufVxuY29uc3QgcnIgPSAoXG4gIC8vIFByZWZlciBSZWFjdCdzIGB1c2VJZGAgaWYgaXQncyBhdmFpbGFibGUuXG4gIGNlLnVzZUlkID8/IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGkgPSB0cigpLCBbbywgcl0gPSBjZS51c2VTdGF0ZShpID8gKCkgPT4gcS5uZXh0SWQoKSA6IG51bGwpO1xuICAgIHJldHVybiBudCgoKSA9PiB7XG4gICAgICBvID09PSBudWxsICYmIHIocS5uZXh0SWQoKSk7XG4gICAgfSwgW29dKSwgbyAhPSBudWxsID8gYCR7b31gIDogdm9pZCAwO1xuICB9XG4pO1xuZnVuY3Rpb24gbnIodCwgaSwgbywgcikge1xuICBTKCgpID0+IHtcbiAgICBjb25zdCB1ID0gW107XG4gICAgKHR5cGVvZiByLm9mZnNldCA9PSBcIm51bWJlclwiIHx8IHR5cGVvZiByLm9mZnNldCA9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiByLm9mZnNldCA9PSBcImZ1bmN0aW9uXCIpICYmIHUucHVzaChIdChyLm9mZnNldCkpLCAoci5mbGlwID09PSAhMCB8fCB0eXBlb2Ygci5mbGlwID09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHIuZmxpcCA9PSBcIm9iamVjdFwiKSAmJiB1LnB1c2gocXQoe1xuICAgICAgcGFkZGluZzogdHlwZW9mIHIuZmxpcCA9PSBcIm51bWJlclwiID8gci5mbGlwIDogdm9pZCAwLFxuICAgICAgLi4udHlwZW9mIHIuZmxpcCA9PSBcIm9iamVjdFwiID8gci5mbGlwIDoge31cbiAgICB9KSksIChyLnNoaWZ0ID09PSAhMCB8fCB0eXBlb2Ygci5zaGlmdCA9PSBcIm51bWJlclwiIHx8IHR5cGVvZiByLnNoaWZ0ID09IFwib2JqZWN0XCIpICYmIHUucHVzaChYdCh7XG4gICAgICBwYWRkaW5nOiB0eXBlb2Ygci5zaGlmdCA9PSBcIm51bWJlclwiID8gci5zaGlmdCA6IHZvaWQgMCxcbiAgICAgIC4uLnR5cGVvZiByLnNoaWZ0ID09IFwib2JqZWN0XCIgPyByLnNoaWZ0IDoge31cbiAgICB9KSksIChyLmF1dG9QbGFjZW1lbnQgPT09ICEwIHx8IHR5cGVvZiByLmF1dG9QbGFjZW1lbnQgPT0gXCJvYmplY3RcIikgJiYgdS5wdXNoKEp0KFxuICAgICAgdHlwZW9mIHIuYXV0b1BsYWNlbWVudCA9PSBcIm9iamVjdFwiID8gci5hdXRvUGxhY2VtZW50IDogdm9pZCAwXG4gICAgKSksIChyLmFycm93ID09PSAhMCB8fCB0eXBlb2Ygci5hcnJvdyA9PSBcIm51bWJlclwiKSAmJiB1LnB1c2goQnQoe1xuICAgICAgZWxlbWVudDogbyxcbiAgICAgIHBhZGRpbmc6IHIuYXJyb3cgPT09ICEwID8gMCA6IHIuYXJyb3dcbiAgICB9KSksIHUucHVzaCguLi50eXBlb2Ygci5taWRkbGV3YXJlID09IFwiZnVuY3Rpb25cIiA/IHIubWlkZGxld2FyZSh7XG4gICAgICByZWZlcmVuY2VFbDogaS5yZWZlcmVuY2UsXG4gICAgICBmbG9hdGluZ0VsOiBpLmZsb2F0aW5nXG4gICAgfSkgOiByLm1pZGRsZXdhcmUgfHwgW10pLCAoci5oaWRlID09PSAhMCB8fCB0eXBlb2Ygci5oaWRlID09IFwib2JqZWN0XCIpICYmIHUucHVzaChHdChcbiAgICAgIHR5cGVvZiByLmhpZGUgPT0gXCJvYmplY3RcIiA/IHIuaGlkZSA6IHZvaWQgMFxuICAgICkpLCB0KHUpO1xuICB9LCBbXG4gICAgci5vZmZzZXQsXG4gICAgci5zaGlmdCxcbiAgICByLmZsaXAsXG4gICAgci5hcnJvdyxcbiAgICByLmF1dG9QbGFjZW1lbnQsXG4gICAgci5oaWRlLFxuICAgIHIubWlkZGxld2FyZVxuICBdKTtcbn1cbmZ1bmN0aW9uIG9yKHQsIGksIG8pIHtcbiAgUygoKSA9PiB7XG4gICAgaWYgKHQgJiYgcS5pc0NsaWVudCAmJiB0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgPCBcInVcIiAmJiBpLmN1cnJlbnQgJiYgaS5jdXJyZW50IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgY29uc3QgciA9IG5ldyBSZXNpemVPYnNlcnZlcigoW3VdKSA9PiB7XG4gICAgICAgIGNvbnN0IGggPSB1LmJvcmRlckJveFNpemUucmVkdWNlKChmLCB7IGlubGluZVNpemU6IG0gfSkgPT4gZiArIG0sIDApO1xuICAgICAgICBvKGgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gci5vYnNlcnZlKGkuY3VycmVudCksICgpID0+IHtcbiAgICAgICAgci5kaXNjb25uZWN0KCksIG8obnVsbCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW10pO1xufVxuY29uc3QgRXIgPSBbXG4gIFwib3JpZ2luLWJvdHRvbVwiLFxuICBcIm9yaWdpbi10b3BcIixcbiAgXCJvcmlnaW4tcmlnaHRcIixcbiAgXCJvcmlnaW4tbGVmdFwiLFxuICBcIm9yaWdpbi1ib3R0b20tbGVmdFwiLFxuICBcIm9yaWdpbi1ib3R0b20tcmlnaHRcIixcbiAgXCJvcmlnaW4tdG9wLWxlZnRcIixcbiAgXCJvcmlnaW4tdG9wLXJpZ2h0XCJcbl0sIGlyID0gKHQpID0+IHtcbiAgc3dpdGNoICh0KSB7XG4gICAgY2FzZSBcInRvcFwiOlxuICAgICAgcmV0dXJuIFwib3JpZ2luLWJvdHRvbVwiO1xuICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgIHJldHVybiBcIm9yaWdpbi10b3BcIjtcbiAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgcmV0dXJuIFwib3JpZ2luLXJpZ2h0XCI7XG4gICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICByZXR1cm4gXCJvcmlnaW4tbGVmdFwiO1xuICAgIGNhc2UgXCJ0b3Atc3RhcnRcIjpcbiAgICBjYXNlIFwicmlnaHQtZW5kXCI6XG4gICAgICByZXR1cm4gXCJvcmlnaW4tYm90dG9tLWxlZnRcIjtcbiAgICBjYXNlIFwidG9wLWVuZFwiOlxuICAgIGNhc2UgXCJsZWZ0LWVuZFwiOlxuICAgICAgcmV0dXJuIFwib3JpZ2luLWJvdHRvbS1yaWdodFwiO1xuICAgIGNhc2UgXCJyaWdodC1zdGFydFwiOlxuICAgIGNhc2UgXCJib3R0b20tc3RhcnRcIjpcbiAgICAgIHJldHVybiBcIm9yaWdpbi10b3AtbGVmdFwiO1xuICAgIGNhc2UgXCJsZWZ0LXN0YXJ0XCI6XG4gICAgY2FzZSBcImJvdHRvbS1lbmRcIjpcbiAgICAgIHJldHVybiBcIm9yaWdpbi10b3AtcmlnaHRcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwib3JpZ2luLWNlbnRlclwiO1xuICB9XG59LCB3ciA9IFtcbiAgXCJvcmlnaW4tYm90dG9tXCIsXG4gIFwib3JpZ2luLXRvcFwiLFxuICBcImx0cjpvcmlnaW4tcmlnaHQgcnRsOm9yaWdpbi1sZWZ0XCIsXG4gIFwibHRyOm9yaWdpbi1sZWZ0IHJ0bDpvcmlnaW4tcmlnaHRcIixcbiAgXCJsdHI6b3JpZ2luLWJvdHRvbS1sZWZ0IHJ0bDpvcmlnaW4tYm90dG9tLXJpZ2h0XCIsXG4gIFwibHRyOm9yaWdpbi1ib3R0b20tcmlnaHQgcnRsOm9yaWdpbi1ib3R0b20tbGVmdFwiLFxuICBcImx0cjpvcmlnaW4tdG9wLWxlZnQgcnRsOm9yaWdpbi10b3AtcmlnaHRcIixcbiAgXCJsdHI6b3JpZ2luLXRvcC1yaWdodCBydGw6b3JpZ2luLXRvcC1sZWZ0XCJcbl0sIFJyID0gKHQpID0+IHtcbiAgc3dpdGNoICh0KSB7XG4gICAgY2FzZSBcInRvcFwiOlxuICAgICAgcmV0dXJuIFwib3JpZ2luLWJvdHRvbVwiO1xuICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgIHJldHVybiBcIm9yaWdpbi10b3BcIjtcbiAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgcmV0dXJuIFwibHRyOm9yaWdpbi1yaWdodCBydGw6b3JpZ2luLWxlZnRcIjtcbiAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgIHJldHVybiBcImx0cjpvcmlnaW4tbGVmdCBydGw6b3JpZ2luLXJpZ2h0XCI7XG4gICAgY2FzZSBcInRvcC1zdGFydFwiOlxuICAgIGNhc2UgXCJyaWdodC1lbmRcIjpcbiAgICAgIHJldHVybiBcImx0cjpvcmlnaW4tYm90dG9tLWxlZnQgcnRsOm9yaWdpbi1ib3R0b20tcmlnaHRcIjtcbiAgICBjYXNlIFwidG9wLWVuZFwiOlxuICAgIGNhc2UgXCJsZWZ0LWVuZFwiOlxuICAgICAgcmV0dXJuIFwibHRyOm9yaWdpbi1ib3R0b20tcmlnaHQgcnRsOm9yaWdpbi1ib3R0b20tbGVmdFwiO1xuICAgIGNhc2UgXCJyaWdodC1zdGFydFwiOlxuICAgIGNhc2UgXCJib3R0b20tc3RhcnRcIjpcbiAgICAgIHJldHVybiBcImx0cjpvcmlnaW4tdG9wLWxlZnQgcnRsOm9yaWdpbi10b3AtcmlnaHRcIjtcbiAgICBjYXNlIFwibGVmdC1zdGFydFwiOlxuICAgIGNhc2UgXCJib3R0b20tZW5kXCI6XG4gICAgICByZXR1cm4gXCJsdHI6b3JpZ2luLXRvcC1yaWdodCBydGw6b3JpZ2luLXRvcC1sZWZ0XCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcIm9yaWdpbi1jZW50ZXJcIjtcbiAgfVxufTtcbmZ1bmN0aW9uIGFyKHQsIGkpIHtcbiAgcmV0dXJuIFgoKCkgPT4gdHlwZW9mIHQub3JpZ2luQ2xhc3MgPT0gXCJmdW5jdGlvblwiID8gdC5vcmlnaW5DbGFzcyhpKSA6IHR5cGVvZiB0Lm9yaWdpbkNsYXNzID09IFwic3RyaW5nXCIgPyB0Lm9yaWdpbkNsYXNzIDogdC50YWlsd2luZGNzc09yaWdpbkNsYXNzID8gaXIoaSkgOiBcIlwiLCBbaSwgdC5vcmlnaW5DbGFzcywgdC50YWlsd2luZGNzc09yaWdpbkNsYXNzXSk7XG59XG5mdW5jdGlvbiBvdCh0LCBpLCAuLi5vKSB7XG4gIGlmICh0IGluIGkpIHtcbiAgICBjb25zdCB1ID0gaVt0XTtcbiAgICByZXR1cm4gdHlwZW9mIHUgPT0gXCJmdW5jdGlvblwiID8gdSguLi5vKSA6IHU7XG4gIH1cbiAgY29uc3QgciA9IG5ldyBFcnJvcihcbiAgICBgVHJpZWQgdG8gaGFuZGxlIFwiJHt0fVwiIGJ1dCB0aGVyZSBpcyBubyBoYW5kbGVyIGRlZmluZWQuIE9ubHkgZGVmaW5lZCBoYW5kbGVycyBhcmU6ICR7T2JqZWN0LmtleXMoXG4gICAgICBpXG4gICAgKS5tYXAoKHUpID0+IGBcIiR7dX1cImApLmpvaW4oXCIsIFwiKX0uYFxuICApO1xuICB0aHJvdyBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSAmJiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShyLCBvdCksIHI7XG59XG5mdW5jdGlvbiBpdCh0KSB7XG4gIHJldHVybiBxLmlzU2VydmVyID8gbnVsbCA6IHQgaW5zdGFuY2VvZiBOb2RlID8gdC5vd25lckRvY3VtZW50IDogdCAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCwgXCJjdXJyZW50XCIpICYmIHQuY3VycmVudCBpbnN0YW5jZW9mIE5vZGUgPyB0LmN1cnJlbnQub3duZXJEb2N1bWVudCA6IGRvY3VtZW50O1xufVxuY29uc3QgdHQgPSBbXG4gIFwiW2NvbnRlbnRFZGl0YWJsZT10cnVlXVwiLFxuICBcIlt0YWJpbmRleF1cIixcbiAgXCJhW2hyZWZdXCIsXG4gIFwiYXJlYVtocmVmXVwiLFxuICBcImJ1dHRvbjpub3QoW2Rpc2FibGVkXSlcIixcbiAgXCJpZnJhbWVcIixcbiAgXCJpbnB1dDpub3QoW2Rpc2FibGVkXSlcIixcbiAgXCJzZWxlY3Q6bm90KFtkaXNhYmxlZF0pXCIsXG4gIFwidGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pXCJcbl0ubWFwKFxuICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBvbmNlIEpTRE9NIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBhbiBlbGVtZW50IHRoYXQgaXNcbiAgLy8gXCJoaWRkZW5cIiBjYW4gYmUgdGhlIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQsIGJlY2F1c2UgdGhpcyBpcyBub3QgcG9zc2libGVcbiAgLy8gaW4gcmVhbCBicm93c2Vycy5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwidGVzdFwiID8gKHQpID0+IGAke3R9Om5vdChbdGFiaW5kZXg9Jy0xJ10pOm5vdChbc3R5bGUqPSdkaXNwbGF5OiBub25lJ10pYCA6ICh0KSA9PiBgJHt0fTpub3QoW3RhYmluZGV4PSctMSddKWBcbikuam9pbihcIixcIik7XG52YXIgYXQgPSAvKiBAX19QVVJFX18gKi8gKCh0KSA9PiAodFt0LlN0cmljdCA9IDBdID0gXCJTdHJpY3RcIiwgdFt0Lkxvb3NlID0gMV0gPSBcIkxvb3NlXCIsIHQpKShhdCB8fCB7fSk7XG5mdW5jdGlvbiB1cih0LCBpID0gMCkge1xuICB2YXIgbztcbiAgcmV0dXJuIHQgPT09ICgobyA9IGl0KHQpKSA9PSBudWxsID8gdm9pZCAwIDogby5ib2R5KSA/ICExIDogb3QoaSwge1xuICAgIDAoKSB7XG4gICAgICByZXR1cm4gdC5tYXRjaGVzKHR0KTtcbiAgICB9LFxuICAgIDEoKSB7XG4gICAgICBsZXQgciA9IHQ7XG4gICAgICBmb3IgKDsgciAhPT0gbnVsbDsgKSB7XG4gICAgICAgIGlmIChyLm1hdGNoZXModHQpKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgciA9IHIucGFyZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gc3IodCkge1xuICBjb25zdCBpID0gSCh0KTtcbiAgcmV0dXJuIG50KCgpID0+IHtcbiAgICBpLmN1cnJlbnQgPSB0O1xuICB9LCBbdF0pLCBpO1xufVxuZnVuY3Rpb24gSSh0LCBpLCBvKSB7XG4gIGNvbnN0IHIgPSBzcihpKTtcbiAgUygoKSA9PiB7XG4gICAgZnVuY3Rpb24gdShoKSB7XG4gICAgICByLmN1cnJlbnQoaCk7XG4gICAgfVxuICAgIHJldHVybiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKHQsIHUsIG8pLCAoKSA9PiBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHQsIHUsIG8pO1xuICB9LCBbdCwgb10pO1xufVxuZnVuY3Rpb24gY3IodCwgaSwgbyA9ICEwKSB7XG4gIGNvbnN0IHIgPSBIKCExKTtcbiAgUyhcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJ0ZXN0XCIgPyAoKSA9PiB7XG4gICAgICByLmN1cnJlbnQgPSBvO1xuICAgIH0gOiAoKSA9PiB7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICByLmN1cnJlbnQgPSBvO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBbb11cbiAgKTtcbiAgZnVuY3Rpb24gdShmLCBtKSB7XG4gICAgaWYgKCFyLmN1cnJlbnQgfHwgZi5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGQgPSBmdW5jdGlvbiBsKHMpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgcyA9PSBcImZ1bmN0aW9uXCIgPyBsKHMoKSkgOiBBcnJheS5pc0FycmF5KHMpIHx8IHMgaW5zdGFuY2VvZiBTZXQgPyBzIDogW3NdO1xuICAgIH0odCksIGIgPSBtKGYpO1xuICAgIGlmIChiICE9PSBudWxsICYmIGIuZ2V0Um9vdE5vZGUoKS5jb250YWlucyhiKSkge1xuICAgICAgZm9yIChjb25zdCBsIG9mIGQpIHtcbiAgICAgICAgaWYgKGwgPT09IG51bGwpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IHMgPSBsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgPyBsIDogbC5jdXJyZW50O1xuICAgICAgICBpZiAocyAhPSBudWxsICYmIHMuY29udGFpbnMoYikgfHwgZi5jb21wb3NlZCAmJiBmLmNvbXBvc2VkUGF0aCgpLmluY2x1ZGVzKHMpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoXG4gICAgICAgIC8vIFRoaXMgY2hlY2sgYWxsbG93cyB1cyB0byBrbm93IHdoZXRoZXIgb3Igbm90IHdlIGNsaWNrZWQgb24gYSBcImZvY3VzYWJsZVwiIGVsZW1lbnQgbGlrZSBhXG4gICAgICAgIC8vIGJ1dHRvbiBvciBhbiBpbnB1dC4gVGhpcyBpcyBhIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGNoZWNrIHNvIHRoYXQgeW91IGNhbiBvcGVuIGEgPE1lbnVcbiAgICAgICAgLy8gLz4gYW5kIGNsaWNrIG9uIGFub3RoZXIgPE1lbnUgLz4gd2hpY2ggc2hvdWxkIGNsb3NlIE1lbnUgQSBhbmQgb3BlbiBNZW51IEIuIFdlIG1pZ2h0XG4gICAgICAgIC8vIHJldmlzaXQgdGhhdCBzbyB0aGF0IHlvdSB3aWxsIHJlcXVpcmUgMiBjbGlja3MgaW5zdGVhZC5cbiAgICAgICAgIXVyKGIsIGF0Lkxvb3NlKSAmJiAvLyBUaGlzIGNvdWxkIGJlIGltcHJvdmVkLCBidXQgdGhlIGBDb21ib2JveC5CdXR0b25gIGFkZHMgdGFiSW5kZXg9ey0xfSB0byBtYWtlIGl0XG4gICAgICAgIC8vIHVuZm9jdXNhYmxlIHZpYSB0aGUga2V5Ym9hcmQgc28gdGhhdCB0YWJiaW5nIHRvIHRoZSBuZXh0IGl0ZW0gZnJvbSB0aGUgaW5wdXQgZG9lc24ndFxuICAgICAgICAvLyBmaXJzdCBnbyB0byB0aGUgYnV0dG9uLlxuICAgICAgICBiLnRhYkluZGV4ICE9PSAtMSAmJiBmLnByZXZlbnREZWZhdWx0KCksIGkoZiwgYilcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGggPSBIKG51bGwpO1xuICBJKFwibW91c2Vkb3duXCIsIChmKSA9PiB7XG4gICAgdmFyIG0sIGQ7XG4gICAgci5jdXJyZW50ICYmIChoLmN1cnJlbnQgPSAoKGQgPSAobSA9IGYuY29tcG9zZWRQYXRoKSA9PSBudWxsID8gdm9pZCAwIDogbS5jYWxsKGYpKSA9PSBudWxsID8gdm9pZCAwIDogZFswXSkgfHwgZi50YXJnZXQpO1xuICB9LCAhMCksIEkoXG4gICAgXCJjbGlja1wiLFxuICAgIChmKSA9PiB7XG4gICAgICBoLmN1cnJlbnQgJiYgKHUoZiwgKCkgPT4gaC5jdXJyZW50KSwgaC5jdXJyZW50ID0gbnVsbCk7XG4gICAgfSxcbiAgICAvLyBXZSB3aWxsIHVzZSB0aGUgYGNhcHR1cmVgIHBoYXNlIHNvIHRoYXQgbGF5ZXJzIGluIGJldHdlZW4gd2l0aCBgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClgXG4gICAgLy8gZG9uJ3QgXCJjYW5jZWxcIiB0aGlzIG91dHNpZGUgY2xpY2sgY2hlY2suIEUuZy46IEEgYE1lbnVgIGluc2lkZSBhIGBEaWFsb2dQYW5lbGAgaWYgdGhlIGBNZW51YFxuICAgIC8vIGlzIG9wZW4sIGFuZCB5b3UgY2xpY2sgb3V0c2lkZSBvZiBpdCBpbiB0aGUgYERpYWxvZ1BhbmVsYCB0aGUgYE1lbnVgIHNob3VsZCBjbG9zZS4gSG93ZXZlcixcbiAgICAvLyB0aGUgYERpYWxvZ1BhbmVsYCBoYXMgYSBgb25DbGljayhlKSB7IGUuc3RvcFByb3BhZ2F0aW9uKCkgfWAgd2hpY2ggd291bGQgY2FuY2VsIHRoaXMuXG4gICAgITBcbiAgKSwgSShcImJsdXJcIiwgKGYpID0+IHUoXG4gICAgZixcbiAgICAoKSA9PiB3aW5kb3cuZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxJRnJhbWVFbGVtZW50ID8gd2luZG93LmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgOiBudWxsXG4gICksICEwKTtcbn1cbmNvbnN0IHNlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwga2UgPSBPZShudWxsKTtcbmtlLmRpc3BsYXlOYW1lID0gXCJSZWZlcmVuY2VDb250ZXh0XCI7XG5jb25zdCBBZSA9IE9lKG51bGwpO1xuQWUuZGlzcGxheU5hbWUgPSBcIkZsb2F0aW5nQ29udGV4dFwiO1xuY29uc3QgdGUgPSBPZShudWxsKTtcbnRlLmRpc3BsYXlOYW1lID0gXCJBcnJvd0NvbnRleHRcIjtcbmZ1bmN0aW9uIHV0KHQpIHtcbiAgY29uc3QgaSA9IEZlKGtlKTtcbiAgaWYgKGkgPT09IG51bGwpIHtcbiAgICBjb25zdCBvID0gbmV3IEVycm9yKGA8JHt0fSAvPiBpcyBtaXNzaW5nIGEgcGFyZW50IDxGbG9hdCAvPiBjb21wb25lbnQuYCk7XG4gICAgdGhyb3cgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgJiYgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UobywgdXQpLCBvO1xuICB9XG4gIHJldHVybiBpO1xufVxuZnVuY3Rpb24gc3QodCkge1xuICBjb25zdCBpID0gRmUoQWUpO1xuICBpZiAoaSA9PT0gbnVsbCkge1xuICAgIGNvbnN0IG8gPSBuZXcgRXJyb3IoYDwke3R9IC8+IGlzIG1pc3NpbmcgYSBwYXJlbnQgPEZsb2F0IC8+IGNvbXBvbmVudC5gKTtcbiAgICB0aHJvdyBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSAmJiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShvLCBzdCksIG87XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiBjdCh0KSB7XG4gIGNvbnN0IGkgPSBGZSh0ZSk7XG4gIGlmIChpID09PSBudWxsKSB7XG4gICAgY29uc3QgbyA9IG5ldyBFcnJvcihgPCR7dH0gLz4gaXMgbWlzc2luZyBhIHBhcmVudCA8RmxvYXQgLz4gY29tcG9uZW50LmApO1xuICAgIHRocm93IEVycm9yLmNhcHR1cmVTdGFja1RyYWNlICYmIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKG8sIGN0KSwgbztcbiAgfVxuICByZXR1cm4gaTtcbn1cbmZ1bmN0aW9uIGx0KHQsIGksIG8sIHIpIHtcbiAgY29uc3QgeyByZWZlcmVuY2VSZWY6IHUgfSA9IHIsIGggPSBpO1xuICBpZiAoaC5hcyA9PT0gailcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIEUuanN4KFxuICAgICAgdC50eXBlLFxuICAgICAge1xuICAgICAgICAuLi50LnByb3BzLFxuICAgICAgICAuLi5vLFxuICAgICAgICByZWY6IHVcbiAgICAgIH1cbiAgICApO1xuICBjb25zdCBmID0gaC5hcyB8fCBcImRpdlwiO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIEUuanN4KGYsIHsgLi4ubywgcmVmOiB1LCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIEUuanN4KHQudHlwZSwgeyAuLi50LnByb3BzIH0pIH0pO1xufVxuZnVuY3Rpb24gJGUodCwgaSwgbywgcikge1xuICBjb25zdCB7IGZsb2F0aW5nUmVmOiB1LCBwcm9wczogaCwgbW91bnRlZDogZiwgc2V0U2hvdzogbSwgeDogZCwgeTogYiwgcGxhY2VtZW50OiBsLCBzdHJhdGVneTogcywgcmVmZXJlbmNlRWxXaWR0aDogQyB9ID0gciwgeSA9IHtcbiAgICAuLi5oLFxuICAgIC4uLmlcbiAgfSwgUiA9IGFyKHksIGwpLCBPID0ge1xuICAgIHNob3c6IGYuY3VycmVudCA/IHkuc2hvdyA6ICExLFxuICAgIGVudGVyOiBgJHt5LmVudGVyIHx8IFwiXCJ9ICR7Un1gLFxuICAgIGVudGVyRnJvbTogYCR7eS5lbnRlckZyb20gfHwgXCJcIn1gLFxuICAgIGVudGVyVG86IGAke3kuZW50ZXJUbyB8fCBcIlwifWAsXG4gICAgbGVhdmU6IGAke3kubGVhdmUgfHwgXCJcIn0gJHtSfWAsXG4gICAgbGVhdmVGcm9tOiBgJHt5LmxlYXZlRnJvbSB8fCBcIlwifWAsXG4gICAgbGVhdmVUbzogYCR7eS5sZWF2ZVRvIHx8IFwiXCJ9YCxcbiAgICBiZWZvcmVFbnRlcjogKCkgPT4ge1xuICAgICAgbSghMCk7XG4gICAgfSxcbiAgICBhZnRlckxlYXZlOiAoKSA9PiB7XG4gICAgICBtKCExKTtcbiAgICB9XG4gIH0sIFcgPSB7XG4gICAgc3R5bGU6IHtcbiAgICAgIC8vIElmIGVuYWJsZSBkaWFsb2cgbW9kZSwgdGhlbiBzZXQgYHRyYW5zZm9ybWAgdG8gZmFsc2UuXG4gICAgICAuLi4heS5kaWFsb2cgJiYgeS50cmFuc2Zvcm0gPyB7XG4gICAgICAgIHBvc2l0aW9uOiBzLFxuICAgICAgICB6SW5kZXg6IHkuekluZGV4IHx8IDk5OTksXG4gICAgICAgIHRvcDogXCIwcHhcIixcbiAgICAgICAgbGVmdDogXCIwcHhcIixcbiAgICAgICAgcmlnaHQ6IFwiYXV0b1wiLFxuICAgICAgICBib3R0b206IFwiYXV0b1wiLFxuICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHt6KGQgfHwgMCl9cHgsJHt6KGIgfHwgMCl9cHgpYFxuICAgICAgfSA6IHtcbiAgICAgICAgcG9zaXRpb246IHMsXG4gICAgICAgIHpJbmRleDogeS56SW5kZXggfHwgOTk5OSxcbiAgICAgICAgdG9wOiBgJHt6KGIgfHwgMCl9cHhgLFxuICAgICAgICBsZWZ0OiBgJHt6KGQgfHwgMCl9cHhgXG4gICAgICB9LFxuICAgICAgd2lkdGg6IHkuYWRhcHRpdmVXaWR0aCAmJiB0eXBlb2YgQyA9PSBcIm51bWJlclwiID8gYCR7Q31weGAgOiB2b2lkIDBcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIEEoRikge1xuICAgIHJldHVybiB5LnBvcnRhbCA/IC8qIEBfX1BVUkVfXyAqLyBFLmpzeChWdCwgeyBjaGlsZHJlbjogRiB9KSA6IEY7XG4gIH1cbiAgZnVuY3Rpb24geChGKSB7XG4gICAgY29uc3QgTiA9IHtcbiAgICAgIC4uLlcsXG4gICAgICAuLi5vLFxuICAgICAgcmVmOiB1XG4gICAgfTtcbiAgICBpZiAoeS5hcyA9PT0gailcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gRS5qc3goXG4gICAgICAgIEYudHlwZSxcbiAgICAgICAge1xuICAgICAgICAgIC4uLkYucHJvcHMsXG4gICAgICAgICAgLi4uTlxuICAgICAgICB9XG4gICAgICApO1xuICAgIGNvbnN0IE0gPSB5LmFzIHx8IFwiZGl2XCI7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBFLmpzeChNLCB7IC4uLk4sIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gRS5qc3goRi50eXBlLCB7IC4uLkYucHJvcHMgfSkgfSk7XG4gIH1cbiAgZnVuY3Rpb24gWSgpIHtcbiAgICByZXR1cm4gcS5pc1NlcnZlciA/IGYuY3VycmVudCAmJiB5LnNob3cgPyAvKiBAX19QVVJFX18gKi8gRS5qc3godC50eXBlLCB7IC4uLnQucHJvcHMgfSkgOiAvKiBAX19QVVJFX18gKi8gRS5qc3goaiwge30pIDogeS50cmFuc2l0aW9uQ2hpbGQgPyAvKiBAX19QVVJFX18gKi8gRS5qc3goWmUuQ2hpbGQsIHsgYXM6IGosIC4uLk8sIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gRS5qc3godC50eXBlLCB7IC4uLnQucHJvcHMgfSkgfSkgOiAvKiBAX19QVVJFX18gKi8gRS5qc3goWmUsIHsgYXM6IGosIC4uLk8sIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gRS5qc3godC50eXBlLCB7IC4uLnQucHJvcHMgfSkgfSk7XG4gIH1cbiAgcmV0dXJuIEEoXG4gICAgeChcbiAgICAgIFkoKVxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIGZ0KFt0LCBpXSwgbykge1xuICB2YXIgSiwgRztcbiAgY29uc3QgciA9IHJyKCksIHUgPSBIKCExKSwgW2gsIGZdID0gZWUoKSwgbSA9IEgobnVsbCksIGQgPSBYKCgpID0+ICh7XG4gICAgc2hvdzogby5vblNob3cgfHwgKCgpID0+IHtcbiAgICB9KSxcbiAgICBoaWRlOiBvLm9uSGlkZSB8fCAoKCkgPT4ge1xuICAgIH0pLFxuICAgIHVwZGF0ZTogby5vblVwZGF0ZSB8fCAoKCkgPT4ge1xuICAgIH0pXG4gIH0pLCBbby5vblNob3csIG8ub25IaWRlLCBvLm9uVXBkYXRlXSksIHsgeDogYiwgeTogbCwgcGxhY2VtZW50OiBzLCBzdHJhdGVneTogQywgdXBkYXRlOiB5LCByZWZzOiBSLCBtaWRkbGV3YXJlRGF0YTogTyB9ID0genQoe1xuICAgIHBsYWNlbWVudDogby5wbGFjZW1lbnQgfHwgXCJib3R0b20tc3RhcnRcIixcbiAgICBzdHJhdGVneTogby5zdHJhdGVneSxcbiAgICBtaWRkbGV3YXJlOiBoXG4gIH0pLCBbVywgQV0gPSBlZShudWxsKTtcbiAgUygoKSA9PiB7XG4gICAgdS5jdXJyZW50ID0gITA7XG4gIH0sIFtdKSwgUygoKSA9PiB7XG4gICAgdCAmJiAhc2UuZ2V0KHIpID8gKHNlLnNldChyLCAhMCksIGQuc2hvdygpKSA6ICF0ICYmIHNlLmdldChyKSAmJiAoc2UuZGVsZXRlKHIpLCBkLmhpZGUoKSk7XG4gIH0sIFt0XSk7XG4gIGNvbnN0IHggPSBVdCgoKSA9PiB7XG4gICAgeSgpLCBkLnVwZGF0ZSgpO1xuICB9LCBbeSwgZF0pO1xuICBTKHgsIFtvLnBsYWNlbWVudCwgby5zdHJhdGVneSwgaF0pLCBucihmLCBSLCBtLCBvKSwgb3Ioby5hZGFwdGl2ZVdpZHRoLCBSLnJlZmVyZW5jZSwgQSksIFMoKCkgPT4ge1xuICAgIGlmIChSLnJlZmVyZW5jZS5jdXJyZW50ICYmIFIuZmxvYXRpbmcuY3VycmVudCAmJiB0KVxuICAgICAgcmV0dXJuIG8uYXV0b1VwZGF0ZSAhPT0gITEgPyBLdChcbiAgICAgICAgUi5yZWZlcmVuY2UuY3VycmVudCxcbiAgICAgICAgUi5mbG9hdGluZy5jdXJyZW50LFxuICAgICAgICB4LFxuICAgICAgICB0eXBlb2Ygby5hdXRvVXBkYXRlID09IFwib2JqZWN0XCIgPyBvLmF1dG9VcGRhdGUgOiB2b2lkIDBcbiAgICAgICkgOiAoKSA9PiB7XG4gICAgICB9O1xuICB9LCBbdCwgeCwgUl0pO1xuICBjb25zdCBZID0gSCghMCk7XG4gIFMoKCkgPT4ge1xuICAgICEoUi5yZWZlcmVuY2UuY3VycmVudCBpbnN0YW5jZW9mIEVsZW1lbnQpICYmIFIucmVmZXJlbmNlLmN1cnJlbnQgJiYgUi5mbG9hdGluZy5jdXJyZW50ICYmIFkuY3VycmVudCAmJiAoWS5jdXJyZW50ID0gITEsIHgoKSwgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBZLmN1cnJlbnQgPSAhMCwgeCgpO1xuICAgIH0pKTtcbiAgfSwgW1JdKTtcbiAgY29uc3QgRiA9IHtcbiAgICByZWZlcmVuY2VSZWY6IFIuc2V0UmVmZXJlbmNlLFxuICAgIHBsYWNlbWVudDogc1xuICB9LCBOID0ge1xuICAgIGZsb2F0aW5nUmVmOiBSLnNldEZsb2F0aW5nLFxuICAgIHByb3BzOiBvLFxuICAgIG1vdW50ZWQ6IHUsXG4gICAgc2V0U2hvdzogaSxcbiAgICB4OiBiLFxuICAgIHk6IGwsXG4gICAgcGxhY2VtZW50OiBzLFxuICAgIHN0cmF0ZWd5OiBDLFxuICAgIHJlZmVyZW5jZUVsV2lkdGg6IFdcbiAgfSwgTSA9IHtcbiAgICBhcnJvd1JlZjogbSxcbiAgICBwbGFjZW1lbnQ6IHMsXG4gICAgeDogKEogPSBPLmFycm93KSA9PSBudWxsID8gdm9pZCAwIDogSi54LFxuICAgIHk6IChHID0gTy5hcnJvdykgPT0gbnVsbCA/IHZvaWQgMCA6IEcueVxuICB9O1xuICByZXR1cm4geyByZWZlcmVuY2VBcGk6IEYsIGZsb2F0aW5nQXBpOiBOLCBhcnJvd0FwaTogTSwgeDogYiwgeTogbCwgcGxhY2VtZW50OiBzLCBzdHJhdGVneTogQywgdXBkYXRlOiB4LCByZWZzOiBSLCBtaWRkbGV3YXJlRGF0YTogTyB9O1xufVxuY29uc3QgZHQgPSBNdCgodCwgaSkgPT4ge1xuICBjb25zdCBbbywgcl0gPSBlZSh0LnNob3cgPz8gITEpLCB7XG4gICAgcmVmZXJlbmNlQXBpOiB1LFxuICAgIGZsb2F0aW5nQXBpOiBoLFxuICAgIGFycm93QXBpOiBmLFxuICAgIHBsYWNlbWVudDogbVxuICB9ID0gZnQoW28sIHJdLCB0KSwgZCA9IHsgcGxhY2VtZW50OiBtIH0sIFtiLCBsXSA9IHR5cGVvZiB0LmNoaWxkcmVuID09IFwiZnVuY3Rpb25cIiA/IHQuY2hpbGRyZW4oZCkgOiB0LmNoaWxkcmVuO1xuICBpZiAoIXJ0KGIpKVxuICAgIHJldHVybiBjb25zb2xlLndhcm4oXCI8RmxvYXQgLz4gaXMgbWlzc2luZyBhIHJlZmVyZW5jZSBhbmQgZmxvYXRpbmcgZWxlbWVudC5cIiksIC8qIEBfX1BVUkVfXyAqLyBFLmpzeChqLCB7fSk7XG4gIGZ1bmN0aW9uIHMoUikge1xuICAgIGlmICh0LmFzID09PSBqIHx8ICF0LmFzKVxuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBFLmpzeChqLCB7IGNoaWxkcmVuOiBSIH0pO1xuICAgIGNvbnN0IE8gPSB0LmFzO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gRS5qc3goTywgeyByZWY6IGksIGNsYXNzTmFtZTogdC5jbGFzc05hbWUsIGNoaWxkcmVuOiBSIH0pO1xuICB9XG4gIGlmICh0LmNvbXBvc2FibGUgfHwgdC5kaWFsb2cpXG4gICAgcmV0dXJuIHMoXG4gICAgICAvKiBAX19QVVJFX18gKi8gRS5qc3goa2UuUHJvdmlkZXIsIHsgdmFsdWU6IHUsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gRS5qc3goQWUuUHJvdmlkZXIsIHsgdmFsdWU6IGgsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gRS5qc3godGUuUHJvdmlkZXIsIHsgdmFsdWU6IGYsIGNoaWxkcmVuOiB0eXBlb2YgdC5jaGlsZHJlbiA9PSBcImZ1bmN0aW9uXCIgPyB0LmNoaWxkcmVuKGQpIDogdC5jaGlsZHJlbiB9KSB9KSB9LCBcIkZsb2F0aW5nTm9kZVwiKVxuICAgICk7XG4gIGNvbnN0IEMgPSBsdChcbiAgICBiLFxuICAgIHsgYXM6IGogfSxcbiAgICB7IGtleTogXCJyZWZlcmVuY2Utbm9kZVwiIH0sXG4gICAgdVxuICApLCB5ID0gJGUoXG4gICAgbCxcbiAgICB7IGFzOiB0LmZsb2F0aW5nQXMgfHwgXCJkaXZcIiB9LFxuICAgIHt9LFxuICAgIGhcbiAgKTtcbiAgcmV0dXJuIHMoW1xuICAgIEMsXG4gICAgLyogQF9fUFVSRV9fICovIEUuanN4KHRlLlByb3ZpZGVyLCB7IHZhbHVlOiBmLCBjaGlsZHJlbjogeSB9LCBcImZsb2F0aW5nLW5vZGVcIilcbiAgXSk7XG59KTtcbmR0LmRpc3BsYXlOYW1lID0gXCJGbG9hdFwiO1xuZnVuY3Rpb24gbHIodCkge1xuICBpZiAoIXQuY2hpbGRyZW4pXG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBFLmpzeChqLCB7fSk7XG4gIGNvbnN0IGkgPSBYKCgpID0+IHtcbiAgICBjb25zdCB7IGFzOiBoLCBjaGlsZHJlbjogZiwgLi4ubSB9ID0gdDtcbiAgICByZXR1cm4gbTtcbiAgfSwgW3RdKSwgbyA9IHV0KFwiRmxvYXQuUmVmZXJlbmNlXCIpLCB7IHBsYWNlbWVudDogciB9ID0gbywgdSA9IHsgcGxhY2VtZW50OiByIH07XG4gIHJldHVybiBsdChcbiAgICB0eXBlb2YgdC5jaGlsZHJlbiA9PSBcImZ1bmN0aW9uXCIgPyB0LmNoaWxkcmVuKHUpIDogdC5jaGlsZHJlbixcbiAgICB7IC4uLnQsIGFzOiB0LmFzIHx8IGogfSxcbiAgICBpLFxuICAgIG9cbiAgKTtcbn1cbmZ1bmN0aW9uIGZyKHQpIHtcbiAgaWYgKCF0LmNoaWxkcmVuKVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gRS5qc3goaiwge30pO1xuICBjb25zdCBpID0gWCgoKSA9PiB7XG4gICAgY29uc3QgeyBhczogaCwgZW50ZXI6IGYsIGVudGVyRnJvbTogbSwgZW50ZXJUbzogZCwgbGVhdmU6IGIsIGxlYXZlRnJvbTogbCwgbGVhdmVUbzogcywgb3JpZ2luQ2xhc3M6IEMsIHRhaWx3aW5kY3NzT3JpZ2luQ2xhc3M6IHksIHRyYW5zaXRpb25DaGlsZDogUiwgY2hpbGRyZW46IE8sIC4uLlcgfSA9IHQ7XG4gICAgcmV0dXJuIFc7XG4gIH0sIFt0XSksIG8gPSBzdChcIkZsb2F0LkNvbnRlbnRcIiksIHsgcGxhY2VtZW50OiByIH0gPSBvLCB1ID0geyBwbGFjZW1lbnQ6IHIgfTtcbiAgcmV0dXJuICRlKFxuICAgIHR5cGVvZiB0LmNoaWxkcmVuID09IFwiZnVuY3Rpb25cIiA/IHQuY2hpbGRyZW4odSkgOiB0LmNoaWxkcmVuLFxuICAgIHsgLi4udCwgYXM6IHQuYXMgfHwgXCJkaXZcIiB9LFxuICAgIGksXG4gICAgb1xuICApO1xufVxuZnVuY3Rpb24gZHIodCkge1xuICBjb25zdCB7IGFycm93UmVmOiBpLCBwbGFjZW1lbnQ6IG8sIHg6IHIsIHk6IHUgfSA9IGN0KFwiRmxvYXQuQXJyb3dcIiksIGggPSBYKCgpID0+IHtcbiAgICBjb25zdCB7IGFzOiBiLCBvZmZzZXQ6IGwsIGNoaWxkcmVuOiBzLCAuLi5DIH0gPSB0O1xuICAgIHJldHVybiBDO1xuICB9LCBbdF0pLCBmID0ge1xuICAgIHRvcDogXCJib3R0b21cIixcbiAgICByaWdodDogXCJsZWZ0XCIsXG4gICAgYm90dG9tOiBcInRvcFwiLFxuICAgIGxlZnQ6IFwicmlnaHRcIlxuICB9W28uc3BsaXQoXCItXCIpWzBdXSwgbSA9IHtcbiAgICBsZWZ0OiB0eXBlb2YgciA9PSBcIm51bWJlclwiID8gYCR7eihyKX1weGAgOiB2b2lkIDAsXG4gICAgdG9wOiB0eXBlb2YgdSA9PSBcIm51bWJlclwiID8gYCR7eih1KX1weGAgOiB2b2lkIDAsXG4gICAgcmlnaHQ6IHZvaWQgMCxcbiAgICBib3R0b206IHZvaWQgMCxcbiAgICBbZl06IGAkeyh0Lm9mZnNldCA/PyA0KSAqIC0xfXB4YCxcbiAgICAuLi5oLnN0eWxlXG4gIH07XG4gIGlmICh0LmFzID09PSBqKSB7XG4gICAgY29uc3QgYiA9IHsgcGxhY2VtZW50OiBvIH0sIGwgPSB0eXBlb2YgdC5jaGlsZHJlbiA9PSBcImZ1bmN0aW9uXCIgPyB0LmNoaWxkcmVuKGIpIDogdC5jaGlsZHJlbjtcbiAgICByZXR1cm4gIWwgfHwgIXJ0KGwpID8gLyogQF9fUFVSRV9fICovIEUuanN4KGosIHt9KSA6IC8qIEBfX1BVUkVfXyAqLyBFLmpzeChcbiAgICAgIGwudHlwZSxcbiAgICAgIHtcbiAgICAgICAgLi4ubC5wcm9wcyxcbiAgICAgICAgcmVmOiBpLFxuICAgICAgICBzdHlsZTogbVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgY29uc3QgZCA9IHQuYXMgfHwgXCJkaXZcIjtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBFLmpzeChcbiAgICBkLFxuICAgIHtcbiAgICAgIHJlZjogaSxcbiAgICAgIC4uLmgsXG4gICAgICBzdHlsZTogbSxcbiAgICAgIGNoaWxkcmVuOiB0LmNoaWxkcmVuXG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gSWUoeyBvbkluaXRpYWw6IHQsIGNoaWxkcmVuOiBpLCAuLi5vIH0pIHtcbiAgY29uc3QgW3IsIHVdID0gZWUoby5zaG93ID8/ICExKSwgaCA9IFgoKCkgPT4ge1xuICAgIGNvbnN0IHsgYXM6IHksIHNob3c6IFIsIHBsYWNlbWVudDogTywgc3RyYXRlZ3k6IFcsIG9mZnNldDogQSwgc2hpZnQ6IHgsIGZsaXA6IFksIGFycm93OiBGLCBhdXRvUGxhY2VtZW50OiBOLCBoaWRlOiBNLCBhdXRvVXBkYXRlOiBKLCB6SW5kZXg6IEcsIGVudGVyOiBsZSwgZW50ZXJGcm9tOiBEZSwgZW50ZXJUbzogV2UsIGxlYXZlOiBmZSwgbGVhdmVGcm9tOiAkLCBsZWF2ZVRvOiBMLCBvcmlnaW5DbGFzczogVSwgdGFpbHdpbmRjc3NPcmlnaW5DbGFzczogZGUsIHBvcnRhbDogdmUsIHRyYW5zZm9ybTogaGUsIG1pZGRsZXdhcmU6IGdlLCBvblNob3c6IG1lLCBvbkhpZGU6IHllLCBvblVwZGF0ZTogYmUsIC4uLnJlIH0gPSBvO1xuICAgIHJldHVybiByZTtcbiAgfSwgW29dKSwge1xuICAgIGZsb2F0aW5nQXBpOiBmLFxuICAgIGFycm93QXBpOiBtLFxuICAgIHBsYWNlbWVudDogZCxcbiAgICByZWZzOiBiXG4gIH0gPSBmdChbciwgdV0sIG8pO1xuICBTKCgpID0+IHtcbiAgICB1KG8uc2hvdyA/PyAhMSk7XG4gIH0sIFtvLnNob3ddKTtcbiAgZnVuY3Rpb24gbCgpIHtcbiAgICByICYmIHUoITEpO1xuICB9XG4gIGlmICh0KHsgc2hvdzogciwgc2V0U2hvdzogdSwgcGxhY2VtZW50OiBkLCByZWZzOiBiIH0pLCAhaSlcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIEUuanN4KGosIHt9KTtcbiAgY29uc3QgQyA9ICRlKFxuICAgIHR5cGVvZiBpID09IFwiZnVuY3Rpb25cIiA/IGkoeyBwbGFjZW1lbnQ6IGQsIGNsb3NlOiBsIH0pIDogaSxcbiAgICB7XG4gICAgICAuLi5vLFxuICAgICAgYXM6IG8uYXMgfHwgaixcbiAgICAgIHNob3c6IHJcbiAgICB9LFxuICAgIGgsXG4gICAgZlxuICApO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIEUuanN4KHRlLlByb3ZpZGVyLCB7IHZhbHVlOiBtLCBjaGlsZHJlbjogQyB9KTtcbn1cbmZ1bmN0aW9uIHZyKHQpIHtcbiAgZnVuY3Rpb24gaSh7IHNldFNob3c6IG8sIHJlZnM6IHIgfSkge1xuICAgIEkoXCJjb250ZXh0bWVudVwiLCAodSkgPT4ge1xuICAgICAgdS5wcmV2ZW50RGVmYXVsdCgpLCByLnNldFBvc2l0aW9uUmVmZXJlbmNlKHtcbiAgICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgIHg6IHUuY2xpZW50WCxcbiAgICAgICAgICAgIHk6IHUuY2xpZW50WSxcbiAgICAgICAgICAgIHRvcDogdS5jbGllbnRZLFxuICAgICAgICAgICAgbGVmdDogdS5jbGllbnRYLFxuICAgICAgICAgICAgcmlnaHQ6IHUuY2xpZW50WCxcbiAgICAgICAgICAgIGJvdHRvbTogdS5jbGllbnRZXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSksIG8oITApO1xuICAgIH0pLCBjcihyLmZsb2F0aW5nLCAoKSA9PiB7XG4gICAgICBvKCExKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIEUuanN4KFxuICAgIEllLFxuICAgIHtcbiAgICAgIGZsaXA6ICEwLFxuICAgICAgLi4udCxcbiAgICAgIHNob3c6ICExLFxuICAgICAgcG9ydGFsOiAhMCxcbiAgICAgIG9uSW5pdGlhbDogaVxuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIGhyKHsgZ2xvYmFsSGlkZUN1cnNvcjogdCwgLi4uaSB9KSB7XG4gIGZ1bmN0aW9uIG8oeyBzZXRTaG93OiByLCByZWZzOiB1IH0pIHtcbiAgICBmdW5jdGlvbiBoKCkge1xuICAgICAgcighMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGYoKSB7XG4gICAgICByKCExKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbShzKSB7XG4gICAgICB1LnNldFBvc2l0aW9uUmVmZXJlbmNlKHtcbiAgICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgIHg6IHMuY2xpZW50WCxcbiAgICAgICAgICAgIHk6IHMuY2xpZW50WSxcbiAgICAgICAgICAgIHRvcDogcy5jbGllbnRZLFxuICAgICAgICAgICAgbGVmdDogcy5jbGllbnRYLFxuICAgICAgICAgICAgcmlnaHQ6IHMuY2xpZW50WCxcbiAgICAgICAgICAgIGJvdHRvbTogcy5jbGllbnRZXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGQocykge1xuICAgICAgaCgpLCBtKHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiKHMpIHtcbiAgICAgIGgoKSwgbShzLnRvdWNoZXNbMF0pO1xuICAgIH1cbiAgICBjb25zdCBsID0gaXQodS5mbG9hdGluZyk7XG4gICAgbCAmJiAoUygoKSA9PiB7XG4gICAgICBpZiAoKHQgfHwgdCA9PT0gdm9pZCAwKSAmJiAhbC5nZXRFbGVtZW50QnlJZChcImhlYWRsZXN1aS1mbG9hdC1jdXJzb3Itc3R5bGVcIikpIHtcbiAgICAgICAgY29uc3QgcyA9IGwuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgICByZXR1cm4gKGwuaGVhZCB8fCBsLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXSkuYXBwZW5kQ2hpbGQocyksIHMuaWQgPSBcImhlYWRsZXN1aS1mbG9hdC1jdXJzb3Itc3R5bGVcIiwgcy5hcHBlbmRDaGlsZChsLmNyZWF0ZVRleHROb2RlKFtcbiAgICAgICAgICBcIiosICo6OmJlZm9yZSwgKjo6YWZ0ZXIge1wiLFxuICAgICAgICAgIFwiICBjdXJzb3I6IG5vbmUgIWltcG9ydGFudDtcIixcbiAgICAgICAgICBcIn1cIixcbiAgICAgICAgICBcIi5oZWFkbGVzdWktZmxvYXQtY3Vyc29yLXJvb3Qge1wiLFxuICAgICAgICAgIFwiICBwb2ludGVyLWV2ZW50czogbm9uZSAhaW1wb3J0YW50O1wiLFxuICAgICAgICAgIFwifVwiXG4gICAgICAgIF0uam9pbihgXG5gKSkpLCAoKSA9PiB7XG4gICAgICAgICAgdmFyIHk7XG4gICAgICAgICAgcmV0dXJuICh5ID0gbC5nZXRFbGVtZW50QnlJZChcImhlYWRsZXN1aS1mbG9hdC1jdXJzb3Itc3R5bGVcIikpID09IG51bGwgPyB2b2lkIDAgOiB5LnJlbW92ZSgpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIFt0XSksIFwib250b3VjaHN0YXJ0XCIgaW4gd2luZG93IHx8IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDAgPyAoSShcInRvdWNoc3RhcnRcIiwgYiksIEkoXCJ0b3VjaGVuZFwiLCBmKSwgSShcInRvdWNobW92ZVwiLCBiKSkgOiAoSShcIm1vdXNlZW50ZXJcIiwgZCksIEkoXCJtb3VzZWxlYXZlXCIsIGYpLCBJKFwibW91c2Vtb3ZlXCIsIGQpKSk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBFLmpzeChcbiAgICBJZSxcbiAgICB7XG4gICAgICAuLi5pLFxuICAgICAgcG9ydGFsOiAhMCxcbiAgICAgIGNsYXNzTmFtZTogXCJoZWFkbGVzdWktZmxvYXQtY3Vyc29yLXJvb3RcIixcbiAgICAgIG9uSW5pdGlhbDogb1xuICAgIH1cbiAgKTtcbn1cbmNvbnN0IHhyID0gT2JqZWN0LmFzc2lnbihkdCwgeyBSZWZlcmVuY2U6IGxyLCBDb250ZW50OiBmciwgQXJyb3c6IGRyLCBWaXJ0dWFsOiBJZSwgQ29udGV4dE1lbnU6IHZyLCBDdXJzb3I6IGhyIH0pO1xuZXhwb3J0IHtcbiAgeHIgYXMgRmxvYXQsXG4gICRlIGFzIHJlbmRlckZsb2F0aW5nRWxlbWVudCxcbiAgbHQgYXMgcmVuZGVyUmVmZXJlbmNlRWxlbWVudCxcbiAgaXIgYXMgdGFpbHdpbmRjc3NPcmlnaW5DbGFzc1Jlc29sdmVyLFxuICBFciBhcyB0YWlsd2luZGNzc09yaWdpblNhZmVsaXN0LFxuICBSciBhcyB0YWlsd2luZGNzc1J0bE9yaWdpbkNsYXNzUmVzb2x2ZXIsXG4gIHdyIGFzIHRhaWx3aW5kY3NzUnRsT3JpZ2luU2FmZWxpc3QsXG4gIGNyIGFzIHVzZU91dHNpZGVDbGlja1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@headlessui-float/react/dist/headlessui-float.mjs\n");

/***/ })

};
;